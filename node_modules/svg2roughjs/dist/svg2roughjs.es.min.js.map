{"version":3,"file":"svg2roughjs.es.min.js","sources":["../out-tsc/OutputType.js","../out-tsc/dom-helpers.js","../out-tsc/utils.js","../out-tsc/styles/effective-attributes.js","../out-tsc/styles/pattern.js","../out-tsc/svg-units.js","../out-tsc/transformation.js","../out-tsc/styles/colors.js","../out-tsc/styles/pens.js","../out-tsc/styles/styles.js","../out-tsc/geom/primitives.js","../out-tsc/geom/marker.js","../out-tsc/geom/rect.js","../out-tsc/clipping.js","../out-tsc/geom/circle.js","../out-tsc/geom/ellipse.js","../out-tsc/geom/polygon.js","../out-tsc/geom/path.js","../out-tsc/geom/text.js","../out-tsc/processor.js","../out-tsc/geom/use.js","../out-tsc/geom/line.js","../out-tsc/geom/polyline.js","../out-tsc/geom/image.js","../out-tsc/geom/foreign-object.js","../out-tsc/RandomNumberGenerator.js","../out-tsc/Svg2Roughjs.js","../out-tsc/styles/textures.js"],"sourcesContent":["export var OutputType;\n(function (OutputType) {\n    OutputType[OutputType[\"SVG\"] = 0] = \"SVG\";\n    OutputType[OutputType[\"CANVAS\"] = 1] = \"CANVAS\";\n})(OutputType || (OutputType = {}));\n","/**\n * Returns the Node's children, since Node.prototype.children is not available on all browsers.\n * https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/children\n */\nexport function getNodeChildren(element) {\n    if (typeof element.children !== 'undefined') {\n        return element.children;\n    }\n    let i = 0;\n    let node;\n    const nodes = element.childNodes;\n    const children = [];\n    while ((node = nodes[i++])) {\n        if (node.nodeType === 1) {\n            children.push(node);\n        }\n    }\n    return children;\n}\n/**\n * IE doesn't support `element.parentElement` in SVG documents.\n * This helper utilizes `parentNode` and checks for the `nodeType`.\n */\nexport function getParentElement(node) {\n    const parentNode = node.parentNode;\n    if (parentNode && parentNode.nodeType === Node.ELEMENT_NODE) {\n        return parentNode;\n    }\n    return null;\n}\n/**\n * Returns the CSS rules that apply to the given element (ignoring inheritance).\n *\n * Based on https://stackoverflow.com/a/22638396\n */\nexport function getMatchedCssRules(context, el) {\n    const ret = [];\n    el.matches =\n        el.matches ||\n            el.webkitMatchesSelector ||\n            // @ts-expect-error: legacy browser support\n            el.mozMatchesSelector ||\n            // @ts-expect-error: legacy browser support\n            el.msMatchesSelector ||\n            // @ts-expect-error: legacy browser support\n            el.oMatchesSelector;\n    context.styleSheets.forEach(sheet => {\n        const rules = sheet.rules || sheet.cssRules;\n        for (const r in rules) {\n            const rule = rules[r];\n            if (el.matches(rule.selectorText)) {\n                ret.push(rule);\n            }\n        }\n    });\n    return ret;\n}\n/**\n * Moves the child-nodes from the source to a new parent.\n */\nexport function reparentNodes(newParent, source) {\n    while (source.firstChild) {\n        newParent.append(source.firstChild);\n    }\n    return newParent;\n}\n/**\n * Returns the id from the url string\n */\nexport function getIdFromUrl(url) {\n    if (url === null) {\n        return null;\n    }\n    const result = /url\\('#?(.*?)'\\)/.exec(url) || /url\\(\"#?(.*?)\"\\)/.exec(url) || /url\\(#?(.*?)\\)/.exec(url);\n    if (result && result.length > 1) {\n        return result[1];\n    }\n    return null;\n}\n","import { reparentNodes } from './dom-helpers';\n/**\n * Attribute for storing the new clip-path IDs for the sketch output.\n */\nexport const SKETCH_CLIP_ATTRIBUTE = 'data-sketchy-clip-path';\n/**\n * Regexp that detects curved commands in path data.\n */\nconst PATH_CURVES_REGEX = /[acsqt]/i;\n/**\n * Returns the <defs> element of the output SVG sketch.\n */\nexport function getDefsElement(context) {\n    if (context.svgSketchDefs) {\n        return context.svgSketchDefs;\n    }\n    const parent = context.svgSketch;\n    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n    if (parent.childElementCount > 0) {\n        parent.insertBefore(defs, parent.firstElementChild);\n    }\n    else {\n        parent.appendChild(defs);\n    }\n    context.svgSketchDefs = defs;\n    return defs;\n}\nexport function getPointsArray(element) {\n    const pointsAttr = element.getAttribute('points');\n    if (!pointsAttr) {\n        return [];\n    }\n    let coordinateRegexp;\n    if (pointsAttr.indexOf(' ') > 0) {\n        // just assume that the coordinates (or pairs) are separated with space\n        coordinateRegexp = /\\s+/g;\n    }\n    else {\n        // there are no spaces, so assume comma separators\n        coordinateRegexp = /,/g;\n    }\n    const pointList = pointsAttr.split(coordinateRegexp);\n    const points = [];\n    for (let i = 0; i < pointList.length; i++) {\n        const currentEntry = pointList[i];\n        const coordinates = currentEntry.split(',');\n        if (coordinates.length === 2) {\n            points.push({ x: parseFloat(coordinates[0]), y: parseFloat(coordinates[1]) });\n        }\n        else {\n            // space as separators, take next entry as y coordinate\n            const next = i + 1;\n            if (next < pointList.length) {\n                points.push({ x: parseFloat(currentEntry), y: parseFloat(pointList[next]) });\n                // skip the next entry\n                i = next;\n            }\n        }\n    }\n    return points;\n}\n/**\n * Helper method to append the returned `SVGGElement` from Rough.js which\n * also post processes the result e.g. by applying the clip.\n */\nexport function appendSketchElement(context, element, sketchElement) {\n    let sketch = sketchElement;\n    // original element may have a clip-path\n    const sketchClipPathId = element.getAttribute(SKETCH_CLIP_ATTRIBUTE);\n    const applyPencilFilter = context.pencilFilter && element.tagName !== 'text';\n    // wrap it in another container to safely apply post-processing attributes,\n    // though avoid no-op <g> containers\n    const isPlainContainer = sketch.tagName === 'g' && sketch.attributes.length === 0;\n    if (!isPlainContainer && (sketchClipPathId || applyPencilFilter)) {\n        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        g.appendChild(sketch);\n        sketch = g;\n    }\n    if (sketchClipPathId) {\n        sketch.setAttribute('clip-path', `url(#${sketchClipPathId})`);\n        element.removeAttribute(SKETCH_CLIP_ATTRIBUTE);\n    }\n    if (applyPencilFilter) {\n        sketch.setAttribute('filter', 'url(#pencilTextureFilter)');\n    }\n    context.svgSketch.appendChild(sketch);\n}\n/**\n * Helper method to sketch a path.\n * Paths with curves should utilize the preserverVertices option to avoid line disjoints.\n * For non-curved paths it looks nicer to actually allow these diskoints.\n * @returns Returns the sketched SVGElement\n */\nexport function sketchPath(context, path, options) {\n    if (PATH_CURVES_REGEX.test(path)) {\n        options = options ? Object.assign(Object.assign({}, options), { preserveVertices: true }) : { preserveVertices: true };\n    }\n    return context.rc.path(path, options);\n}\n/**\n * Helper funtion to sketch a DOM fragment.\n * Wraps the given element in an SVG and runs the processor on it to sketch the fragment.\n * The result is then unpacked and returned.\n */\nexport function sketchFragment(context, g, roughOverwrites) {\n    const proxySource = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    proxySource.appendChild(g);\n    const proxyContext = Object.assign(Object.assign({}, context), { sourceSvg: proxySource, svgSketch: document.createElementNS('http://www.w3.org/2000/svg', 'svg'), roughConfig: Object.assign(Object.assign({}, context.roughConfig), roughOverwrites) });\n    proxyContext.processElement(proxyContext, g, null);\n    return reparentNodes(document.createElementNS('http://www.w3.org/2000/svg', 'g'), proxyContext.svgSketch);\n}\n/**\n * Measures the text in the context of the sketchSvg to account for inherited text\n * attributes.\n * The given text element must be a child of the svgSketch.\n */\nexport function measureText({ svgSketch, svgSketchIsInDOM }, text) {\n    const hiddenElementStyle = 'visibility:hidden;position:absolute;left:-100%;top-100%;';\n    const origStyle = svgSketch.getAttribute('style');\n    if (origStyle) {\n        svgSketch.setAttribute('style', `${origStyle};${hiddenElementStyle}`);\n    }\n    else {\n        svgSketch.setAttribute('style', hiddenElementStyle);\n    }\n    // the element must be in the DOM for getBBox\n    const body = document.body;\n    const previousParent = svgSketch.parentElement;\n    if (!svgSketchIsInDOM) {\n        body.appendChild(svgSketch);\n    }\n    const { width, height } = text.getBBox();\n    // make sure to not change the DOM hierarchy of the element\n    if (!svgSketchIsInDOM) {\n        body.removeChild(svgSketch);\n        if (previousParent) {\n            previousParent.appendChild(svgSketch);\n        }\n    }\n    if (origStyle) {\n        svgSketch.setAttribute('style', origStyle);\n    }\n    else {\n        svgSketch.removeAttribute('style');\n    }\n    return { w: width, h: height };\n}\n","import { getParentElement } from '../dom-helpers';\n/**\n * Returns the attribute value of an element under consideration\n * of inherited attributes from the `parentElement`.\n * @param attributeName Name of the attribute to look up\n * @param currentUseCtx Consider different DOM hierarchy for use elements\n * @return attribute value if it exists\n */\nexport function getEffectiveAttribute(context, element, attributeName, currentUseCtx) {\n    // getComputedStyle doesn't work for, e.g. <svg fill='rgba(...)'>\n    let attr;\n    if (!currentUseCtx) {\n        attr =\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            getComputedStyle(element)[attributeName] || element.getAttribute(attributeName);\n    }\n    else {\n        // use elements traverse a different parent-hierarchy, thus we cannot use getComputedStyle here\n        attr = element.getAttribute(attributeName);\n    }\n    if (!attr) {\n        let parent = getParentElement(element);\n        const useCtx = currentUseCtx;\n        let nextCtx = useCtx;\n        if (useCtx && useCtx.referenced === element) {\n            // switch context and traverse the use-element parent now\n            parent = useCtx.root;\n            nextCtx = useCtx.parentContext;\n        }\n        if (!parent || parent === context.sourceSvg) {\n            return;\n        }\n        return getEffectiveAttribute(context, parent, attributeName, nextCtx);\n    }\n    return attr;\n}\n/**\n * Traverses the given elements hierarchy bottom-up to determine its effective\n * opacity attribute.\n * @param currentUseCtx Consider different DOM hierarchy for use elements\n */\nexport function getEffectiveElementOpacity(context, element, currentOpacity, currentUseCtx) {\n    let attr;\n    if (!currentUseCtx) {\n        attr = getComputedStyle(element)['opacity'] || element.getAttribute('opacity');\n    }\n    else {\n        // use elements traverse a different parent-hierarchy, thus we cannot use getComputedStyle here\n        attr = element.getAttribute('opacity');\n    }\n    if (attr) {\n        let elementOpacity = 1;\n        if (attr.indexOf('%') !== -1) {\n            elementOpacity = Math.min(1, Math.max(0, parseFloat(attr.substring(0, attr.length - 1)) / 100));\n        }\n        else {\n            elementOpacity = Math.min(1, Math.max(0, parseFloat(attr)));\n        }\n        // combine opacities\n        currentOpacity *= elementOpacity;\n    }\n    // traverse upwards to combine parent opacities as well\n    let parent = getParentElement(element);\n    const useCtx = currentUseCtx;\n    let nextUseCtx = useCtx;\n    if (useCtx && useCtx.referenced === element) {\n        // switch context and traverse the use-element parent now\n        parent = useCtx.root;\n        nextUseCtx = useCtx.parentContext;\n    }\n    if (!parent || parent === context.sourceSvg) {\n        return currentOpacity;\n    }\n    return getEffectiveElementOpacity(context, parent, currentOpacity, nextUseCtx);\n}\n","import { getIdFromUrl, reparentNodes } from '../dom-helpers';\nimport { appendSketchElement, getDefsElement, sketchFragment } from '../utils';\nimport { getEffectiveAttribute } from './effective-attributes';\n/**\n * If the input element has a pattern stroke/fill, an additional element is added to the result,\n * which just provides the pattern storke/fill.\n * @param patternProxyCreator Should return the transformed `SVGElement` that holds the stroke/fill pattern.\n */\nexport function appendPatternPaint(context, sourceElement, patternProxyCreator) {\n    const { fillId, strokeId } = getPatternPaintIds(context, sourceElement);\n    if (fillId !== null || strokeId !== null) {\n        // the additional element that should provide the pattern\n        const patternProxy = patternProxyCreator();\n        patternProxy.setAttribute('fill', fillId !== null ? `url(#${fillId})` : 'none');\n        patternProxy.setAttribute('stroke', strokeId !== null ? `url(#${strokeId})` : 'none');\n        const strokeWidth = getEffectiveAttribute(context, sourceElement, 'stroke-width', context.useElementContext);\n        patternProxy.setAttribute('stroke-width', strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : '0');\n        // append the proxy\n        appendSketchElement(context, sourceElement, patternProxy);\n        // add the pattern defs\n        appendPatternDefsElement(context, fillId);\n        appendPatternDefsElement(context, strokeId);\n    }\n}\n/**\n * Returns the element's referenced fill and stroke pattern ids if there are any.\n */\nfunction getPatternPaintIds(context, element) {\n    function getPatternId(attributeName) {\n        const attr = element.getAttribute(attributeName);\n        if (attr && attr.indexOf('url') !== -1) {\n            const id = getIdFromUrl(attr);\n            if (id) {\n                const paint = context.idElements[id];\n                if (paint instanceof SVGPatternElement) {\n                    return id;\n                }\n            }\n        }\n        return null;\n    }\n    return { fillId: getPatternId('fill'), strokeId: getPatternId('stroke') };\n}\n/**\n * Obtains the pattern fill element from the source SVG and provides it as defs element\n * in the output sketch element if missing.\n */\nfunction appendPatternDefsElement(context, patternId) {\n    if (patternId === null) {\n        return;\n    }\n    const sketchDefs = getDefsElement(context);\n    const defId = `#${patternId}`;\n    if (!sketchDefs.querySelector(defId)) {\n        const sourceDefElement = context.sourceSvg.querySelector(defId);\n        if (sourceDefElement) {\n            if (!context.sketchPatterns) {\n                // just copy the pattern to the output\n                sketchDefs.appendChild(sourceDefElement.cloneNode(true));\n                return;\n            }\n            // create a proxy for the pattern element to be sketched separately\n            const patternElement = reparentNodes(document.createElementNS('http://www.w3.org/2000/svg', 'g'), sourceDefElement.cloneNode(true));\n            // sketch the pattern separately from the main processor loop\n            const sketchPattern = sketchFragment(context, patternElement, {\n                // patterns usually don't benefit from too crazy sketch values due to their base-size\n                fillStyle: 'solid',\n                roughness: 0.5 // TODO ideally this should scale with the pattern's size\n            });\n            // move the result into an copy of the original def element\n            const defElementRoot = sourceDefElement.cloneNode();\n            sketchDefs.appendChild(reparentNodes(defElementRoot, sketchPattern));\n        }\n    }\n}\n","import { getParentElement } from './dom-helpers';\nimport { getEffectiveAttribute } from './styles/effective-attributes';\n/**\n * Dimension parsing regexp.\n *\n * https://www.w3.org/TR/css3-values/#numbers\n * \"a number is either an integer, or zero or more decimal digits\n * followed by a dot (.) followed by one or more decimal digits and\n * optionally an exponent composed of \"e\" or \"E\" and an integer.\"\n *\n * Don't forget the signs though...\n * => ([+-]?(?:\\d+|\\d*\\.\\d+(?:[eE][+-]?\\d+)?))\n *\n * To get the unit, itself, just allow any alphabetic sequence and the '%' char.\n * => ([a-z]*|%)\n */\nconst DIMENSION_REGEX = /^([+-]?(?:\\d+|\\d*\\.\\d+(?:[eE][+-]?\\d+)?))([a-z]*|%)$/;\n/**\n * Commonly used dpi for unit conversion.\n */\nconst DPI = 96;\n/**\n * Conversion factors for absolute units.\n * https://developer.mozilla.org/en-US/docs/web/css/length\n */\nconst ABSOLUTE_UNITS = {\n    in: DPI,\n    cm: DPI / 2.54,\n    mm: DPI / 25.4,\n    pt: DPI / 72,\n    pc: DPI / 6,\n    px: 1\n};\n// pre-calculated factor for % conversion\nconst SQRT2 = Math.sqrt(2);\n/**\n * Converts the given string to px unit. May be either a\n * [length](https://developer.mozilla.org/de/docs/Web/SVG/Content_type#Length)\n * or a [percentage](https://developer.mozilla.org/de/docs/Web/SVG/Content_type#Percentage).\n * @returns The value in px unit\n */\nexport function convertToPixelUnit(context, element, dimensionValue, attribute) {\n    const { value, unit } = parseDimension(dimensionValue);\n    if (isAbsoluteUnit(unit)) {\n        return absToPixel(value, unit);\n    }\n    return relToPixel(context, element, attribute, value, unit);\n}\n/**\n * Parses the given string and returns a dimension, which is a\n * [number](https://www.w3.org/TR/css3-values/#numbers) followed\n * by a unit identifier.\n */\nfunction parseDimension(dimension) {\n    const match = dimension.match(DIMENSION_REGEX);\n    if (match === null || match.length !== 3) {\n        throw new Error(`Cannot parse dimension: ${dimension}`);\n    }\n    return { value: parseFloat(match[1]), unit: match[2].toLowerCase() || 'px' };\n}\n/**\n * unit-css converts per HTML spec, which is differently for percentages in SVG\n * https://www.w3.org/TR/SVG/coords.html#Units\n * https://oreillymedia.github.io/Using_SVG/guide/units.html\n * @param percentage [0, 100]\n * @param viewBox The coordinate system to evaluate the percentage against\n */\nfunction percentageToPixel(attribute, percentage, { w: width, h: height } = { w: 0, h: 0 }) {\n    const fraction = percentage / 100;\n    // x and y are relative to the coordinate system's width or height\n    if (attribute === 'x') {\n        return fraction * width;\n    }\n    if (attribute === 'y') {\n        return fraction * height;\n    }\n    return fraction * (Math.sqrt(width * width + height * height) / SQRT2);\n}\n/**\n * Converts an absolute unit to pixels.\n */\nfunction absToPixel(value, unit) {\n    var _a;\n    const conversion = (_a = ABSOLUTE_UNITS[unit]) !== null && _a !== void 0 ? _a : 1;\n    return value * conversion;\n}\n/**\n * Converts a relative unit to pixels.\n */\nfunction relToPixel(context, element, attribute, value, unit) {\n    var _a;\n    const coordinateSystemSize = (_a = context.viewBox) !== null && _a !== void 0 ? _a : { w: 0, h: 0 };\n    if (unit === '%') {\n        return percentageToPixel(attribute, value, coordinateSystemSize);\n    }\n    if (unit === 'vw' || unit === 'vh' || unit === 'vmin' || unit === 'vmax') {\n        return viewportLengthToPixel(value, unit, coordinateSystemSize);\n    }\n    if (unit === 'em' || unit === 'ex' || unit === 'ch' || unit === 'rem') {\n        return fontRelativeToPixel(context, element, value, unit);\n    }\n    throw new Error(`Unsupported relative length unit: ${unit}`);\n}\n/**\n * https://oreillymedia.github.io/Using_SVG/guide/units.html#units-viewport-reference\n */\nfunction viewportLengthToPixel(value, unit, { w: width, h: height } = { w: 0, h: 0 }) {\n    var _a, _b;\n    const fraction = value / 100;\n    const refWidth = (_a = window.innerWidth) !== null && _a !== void 0 ? _a : width;\n    const refHeight = (_b = window.innerHeight) !== null && _b !== void 0 ? _b : height;\n    if (unit === 'vw') {\n        return fraction * refWidth;\n    }\n    if (unit === 'vh') {\n        return fraction * refHeight;\n    }\n    if (unit === 'vmin') {\n        return fraction * Math.min(refWidth, refHeight);\n    }\n    if (unit === 'vmax') {\n        return fraction * Math.max(refWidth, refHeight);\n    }\n    throw new Error(`Not a viewport length unit: ${unit}`);\n}\n/**\n * https://oreillymedia.github.io/Using_SVG/guide/units.html#units-relative-reference\n */\nfunction fontRelativeToPixel(context, element, value, unit) {\n    var _a;\n    if (unit === 'rem') {\n        const rootElement = document.documentElement;\n        const fontSizeDimension = parseDimension(getComputedStyle(rootElement).fontSize);\n        const fontSizePx = fontSizeDimension.unit === 'px' ? fontSizeDimension.value : 16;\n        return value * fontSizePx;\n    }\n    if (unit === 'ch') {\n        const zeroCharWidth = measureZeroCharacter(element);\n        return value * zeroCharWidth;\n    }\n    // this should return a px font-size due to the getComputedStyle, otherwise use 16px as default fallback\n    const effectiveFontSize = (_a = getEffectiveAttribute(context, element, 'font-size', context.useElementContext)) !== null && _a !== void 0 ? _a : '16px';\n    const fontSizeDimension = parseDimension(effectiveFontSize);\n    const fontSizePx = fontSizeDimension.unit === 'px' ? fontSizeDimension.value : 16;\n    if (unit === 'em') {\n        return value * fontSizePx;\n    }\n    if (unit === 'ex') {\n        return value * fontSizePx * 0.5;\n    }\n    throw new Error(`Not a font relative unit: ${unit}`);\n}\n/**\n * Whether the given unit is an absolute unit.\n */\nfunction isAbsoluteUnit(unit) {\n    return !!ABSOLUTE_UNITS[unit];\n}\n/**\n * Returns the width of the '0' character in the context of the element.\n */\nfunction measureZeroCharacter(element) {\n    const parent = getParentElement(element);\n    if (!parent) {\n        return 1;\n    }\n    const measureContainer = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    measureContainer.style.visibility = 'hidden';\n    measureContainer.appendChild(document.createTextNode('0'));\n    parent.appendChild(measureContainer);\n    const bbox = measureContainer.getBBox();\n    parent.removeChild(measureContainer);\n    return bbox.width;\n}\n","/**\n * Whether the given SVGTransform resembles an identity transform.\n * @returns Whether the transform is an identity transform.\n *  Returns true if transform is undefined.\n */\nexport function isIdentityTransform(svgTransform) {\n    if (!svgTransform) {\n        return true;\n    }\n    const matrix = svgTransform.matrix;\n    return (!matrix ||\n        (matrix.a === 1 &&\n            matrix.b === 0 &&\n            matrix.c === 0 &&\n            matrix.d === 1 &&\n            matrix.e === 0 &&\n            matrix.f === 0));\n}\n/**\n * Whether the given SVGTransform does not scale nor skew.\n * @returns Whether the given SVGTransform does not scale nor skew.\n *  Returns true if transform is undefined.\n */\nexport function isTranslationTransform(svgTransform) {\n    if (!svgTransform) {\n        return true;\n    }\n    const matrix = svgTransform.matrix;\n    return !matrix || (matrix.a === 1 && matrix.b === 0 && matrix.c === 0 && matrix.d === 1);\n}\n/**\n * Applies a given `SVGTransform` to the point.\n *\n * [a c e] [x] = (a*x + c*y + e)\n * [b d f] [y] = (b*x + d*y + f)\n * [0 0 1] [1] = (0 + 0 + 1)\n */\nexport function applyMatrix(point, svgTransform) {\n    if (!svgTransform) {\n        return point;\n    }\n    const matrix = svgTransform.matrix;\n    const x = matrix.a * point.x + matrix.c * point.y + matrix.e;\n    const y = matrix.b * point.x + matrix.d * point.y + matrix.f;\n    return { x, y };\n}\n/**\n * Returns the consolidated transform of the given element.\n */\nexport function getSvgTransform(element) {\n    if (element.transform && element.transform.baseVal.numberOfItems > 0) {\n        return element.transform.baseVal.consolidate();\n    }\n    return null;\n}\n/**\n * Combines the given transform with the element's transform.\n * If no transform is given, it returns the SVGTransform of the element.\n */\nexport function getCombinedTransform(context, element, transform) {\n    if (!transform) {\n        return getSvgTransform(element);\n    }\n    const elementTransform = getSvgTransform(element);\n    if (elementTransform) {\n        const elementTransformMatrix = elementTransform.matrix;\n        const combinedMatrix = transform.matrix.multiply(elementTransformMatrix);\n        return context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);\n    }\n    return transform;\n}\n/**\n * Applies the given svgTransform to the given element.\n * @param element The element to which the transform should be applied.\n */\nexport function applyTransform(context, svgTransform, element) {\n    if (svgTransform && svgTransform.matrix && !isIdentityTransform(svgTransform)) {\n        const matrix = svgTransform.matrix;\n        if (element.transform.baseVal.numberOfItems > 0) {\n            element.transform.baseVal.getItem(0).setMatrix(matrix);\n        }\n        else {\n            element.transform.baseVal.appendItem(svgTransform);\n        }\n    }\n}\n","import tinycolor from 'tinycolor2';\n/**\n * Converts an SVG gradient to a color by mixing all stop colors\n * with `tinycolor.mix`.\n */\nexport function gradientToColor(gradient, opacity) {\n    const stops = Array.prototype.slice.apply(gradient.querySelectorAll('stop'));\n    if (stops.length === 0) {\n        return 'transparent';\n    }\n    else if (stops.length === 1) {\n        const color = getStopColor(stops[0]);\n        color.setAlpha(opacity);\n        return color.toString();\n    }\n    else {\n        // Because roughjs can only deal with solid colors, we try to calculate\n        // the average color of the gradient here.\n        // The idea is to create an array of discrete (average) colors that represents the\n        // gradient under consideration of the stop's offset. Thus, larger offsets\n        // result in more entries of the same mixed color (of the two adjacent color stops).\n        // At the end, this array is averaged again, to create a single solid color.\n        const resolution = 10;\n        const discreteColors = [];\n        let lastColor = null;\n        for (let i = 0; i < stops.length; i++) {\n            const currentColor = getStopColor(stops[i]);\n            const currentOffset = getStopOffset(stops[i]);\n            // combine the adjacent colors\n            const combinedColor = lastColor ? averageColor([lastColor, currentColor]) : currentColor;\n            // fill the discrete color array depending on the offset size\n            let entries = Math.max(1, (currentOffset / resolution) | 0);\n            while (entries > 0) {\n                discreteColors.push(combinedColor);\n                entries--;\n            }\n            lastColor = currentColor;\n        }\n        // average the discrete colors again for the final result\n        const mixedColor = averageColor(discreteColors);\n        mixedColor.setAlpha(opacity);\n        return mixedColor.toString();\n    }\n}\n/**\n * Returns the `stop-color` of an `SVGStopElement`.\n */\nexport function getStopColor(stop) {\n    var _a;\n    let stopColorStr = stop.getAttribute('stop-color');\n    if (!stopColorStr) {\n        const style = (_a = stop.getAttribute('style')) !== null && _a !== void 0 ? _a : '';\n        const match = /stop-color:\\s?(.*);?/.exec(style);\n        if (match && match.length > 1) {\n            stopColorStr = match[1];\n        }\n    }\n    return stopColorStr ? tinycolor(stopColorStr) : tinycolor('white');\n}\n/**\n * Calculates the average color of the colors in the given array.\n * @returns The average color\n */\nexport function averageColor(colorArray) {\n    const count = colorArray.length;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    colorArray.forEach(tinycolor => {\n        const color = tinycolor.toRgb();\n        r += color.r * color.r;\n        g += color.g * color.g;\n        b += color.b * color.b;\n        a += color.a;\n    });\n    return tinycolor({\n        r: Math.sqrt(r / count),\n        g: Math.sqrt(g / count),\n        b: Math.sqrt(b / count),\n        a: a / count\n    });\n}\n/**\n * Returns the `offset` of an `SVGStopElement`.\n * @return stop percentage\n */\nexport function getStopOffset(stop) {\n    const offset = stop.getAttribute('offset');\n    if (!offset) {\n        return 0;\n    }\n    if (offset.indexOf('%')) {\n        return parseFloat(offset.substring(0, offset.length - 1));\n    }\n    else {\n        return parseFloat(offset) * 100;\n    }\n}\n","function getPenConfiguration(fillStyle) {\n    // the svg2roughjs v2 config\n    const legacyConfig = {\n        angle: {\n            normal: [-30, -50],\n            horizontal: [-30, -50],\n            vertical: [-30, -50]\n        },\n        weight: {\n            normal: [0.5, 3],\n            small: [0.5, 3]\n        },\n        gap: {\n            normal: [3, 5],\n            small: [3, 5]\n        }\n    };\n    // adjusted config for more variation\n    const defaultConfig = {\n        angle: {\n            // just lean more into the direction of the aspect ratio\n            normal: [-30, -50],\n            horizontal: [-50, -75],\n            vertical: [-30, -15]\n        },\n        weight: {\n            normal: [1, 3],\n            small: [0.5, 1.7]\n        },\n        gap: {\n            normal: [2, 5],\n            small: [1, 3]\n        }\n    };\n    // fine-tune configs depending on fill-style\n    switch (fillStyle) {\n        default:\n            return defaultConfig;\n        case 'zigzag':\n        case 'zigzag-line':\n            return Object.assign(Object.assign({}, defaultConfig), { weight: { normal: [0.5, 3], small: [0.5, 2] }, gap: { normal: [2, 6], small: [2, 5] } });\n        case 'cross-hatch':\n            return Object.assign(Object.assign({}, defaultConfig), { weight: { normal: [1, 3], small: [0.5, 1.3] }, gap: { normal: [4, 8], small: [2, 5] } });\n        case 'dots':\n            return legacyConfig;\n    }\n}\n/**\n * Creates a random rendering configuration for the given element.\n * The returned pen is specific of the `config.fillStyle` and the element's shape.\n */\nexport function createPen(context, element) {\n    if (context.roughConfig.fillStyle === 'solid') {\n        // config doesn't affect drawing\n        return { angle: 0, gap: 0, weight: 0 };\n    }\n    // Only works when the element is in the DOM, but no need to check it here,\n    // since the related methods can cope with non-finite or zero cases.\n    const { width, height } = element.getBoundingClientRect();\n    const aspectRatio = width / height;\n    const sideLength = Math.sqrt(width * height);\n    const { angle, gap, weight } = getPenConfiguration(context.roughConfig.fillStyle);\n    return {\n        angle: getHachureAngle(context, angle, aspectRatio),\n        gap: getHachureGap(context, gap, sideLength),\n        weight: getFillWeight(context, weight, sideLength)\n    };\n}\n/**\n * Returns a random hachure angle in the range of the given config.\n *\n * Rough.js default is -41deg\n */\nfunction getHachureAngle({ rng }, { normal, horizontal, vertical }, aspectRatio) {\n    if (isFinite(aspectRatio)) {\n        // sketch elements along the smaller side\n        if (aspectRatio < 0.25) {\n            return rng.next(horizontal);\n        }\n        else if (aspectRatio > 6) {\n            return rng.next(vertical);\n        }\n    }\n    return rng.next(normal);\n}\n/**\n * Returns a random hachure gap in the range of the given config.\n *\n * Rough.js default is 4 * strokeWidth\n */\nfunction getHachureGap({ rng }, { normal, small }, sideLength) {\n    return sideLength < 45 ? rng.next(small) : rng.next(normal);\n}\n/**\n * Returns a random fill weight in the range of the given config.\n *\n * Rough.js default is 0.5 * strokeWidth\n */\nfunction getFillWeight({ rng }, { normal, small }, sideLength) {\n    return sideLength < 45 ? rng.next(small) : rng.next(normal);\n}\n","import tinycolor from 'tinycolor2';\nimport { getIdFromUrl } from '../dom-helpers';\nimport { convertToPixelUnit } from '../svg-units';\nimport { isIdentityTransform } from '../transformation';\nimport { gradientToColor } from './colors';\nimport { getEffectiveAttribute, getEffectiveElementOpacity } from './effective-attributes';\nimport { createPen } from './pens';\n/**\n * Converts the effective style attributes of the given `SVGElement`\n * to a Rough.js config object that is used to draw the element with\n * Rough.js.\n * @return config for Rough.js drawing\n */\nexport function parseStyleConfig(context, element, svgTransform) {\n    var _a;\n    const precision = (_a = context.roughConfig.fixedDecimalPlaceDigits) !== null && _a !== void 0 ? _a : 15;\n    const config = Object.assign({}, context.roughConfig);\n    // Scalefactor for certain style attributes. For lack of a better option here, use the determinant\n    let scaleFactor = 1;\n    if (!isIdentityTransform(svgTransform)) {\n        const m = svgTransform.matrix;\n        const det = m.a * m.d - m.c * m.b;\n        scaleFactor = Math.sqrt(Math.abs(det));\n    }\n    // incorporate the elements base opacity\n    const elementOpacity = getEffectiveElementOpacity(context, element, 1, context.useElementContext);\n    const fill = getEffectiveAttribute(context, element, 'fill', context.useElementContext) || 'black';\n    const fillOpacity = elementOpacity * getOpacity(element, 'fill-opacity');\n    if (fill) {\n        if (fill.indexOf('url') !== -1) {\n            const gradientColor = convertGradient(context, fill, fillOpacity);\n            if (gradientColor !== 'none') {\n                config.fill = gradientColor;\n            }\n            else {\n                // delete fill, otherwise it may create an invisible 'hachure' element\n                delete config.fill;\n            }\n        }\n        else if (fill === 'none') {\n            // delete fill, otherwise it may create an invisible 'hachure' element\n            delete config.fill;\n        }\n        else {\n            const color = tinycolor(fill);\n            color.setAlpha(fillOpacity);\n            config.fill = color.toString();\n        }\n    }\n    const stroke = getEffectiveAttribute(context, element, 'stroke', context.useElementContext);\n    const strokeOpacity = elementOpacity * getOpacity(element, 'stroke-opacity');\n    if (stroke) {\n        if (stroke.indexOf('url') !== -1) {\n            config.stroke = convertGradient(context, stroke, strokeOpacity);\n        }\n        else if (stroke === 'none') {\n            config.stroke = 'none';\n        }\n        else {\n            const color = tinycolor(stroke);\n            color.setAlpha(strokeOpacity);\n            config.stroke = color.toString();\n        }\n    }\n    else {\n        config.stroke = 'none';\n    }\n    const strokeWidth = getEffectiveAttribute(context, element, 'stroke-width', context.useElementContext);\n    if (strokeWidth) {\n        // Convert to user space units (px)\n        const scaledWidth = convertToPixelUnit(context, element, strokeWidth, 'stroke-width') * scaleFactor;\n        config.strokeWidth = parseFloat(scaledWidth.toFixed(precision));\n    }\n    else {\n        // default stroke-width is 1\n        config.strokeWidth = 1;\n    }\n    const strokeDashArray = getEffectiveAttribute(context, element, 'stroke-dasharray', context.useElementContext);\n    if (strokeDashArray && strokeDashArray !== 'none') {\n        config.strokeLineDash = strokeDashArray\n            .split(/[\\s,]+/)\n            .filter(entry => entry.length > 0)\n            // make sure that dashes/dots are at least somewhat visible\n            .map(dash => {\n            const scaledLineDash = convertToPixelUnit(context, element, dash, 'stroke-dasharray') * scaleFactor;\n            return Math.max(0.5, parseFloat(scaledLineDash.toFixed(precision)));\n        });\n    }\n    const strokeDashOffset = getEffectiveAttribute(context, element, 'stroke-dashoffset', context.useElementContext);\n    if (strokeDashOffset) {\n        const scaledOffset = convertToPixelUnit(context, element, strokeDashOffset, 'stroke-dashoffset') * scaleFactor;\n        config.strokeLineDashOffset = parseFloat(scaledOffset.toFixed(precision));\n    }\n    // unstroked but filled shapes look weird, so always apply a stroke if we fill something\n    if (config.fill && config.stroke === 'none') {\n        config.stroke = config.fill;\n        config.strokeWidth = 1;\n    }\n    if (context.randomize) {\n        const { angle, gap, weight } = createPen(context, element);\n        config.hachureAngle = angle;\n        config.hachureGap = Math.round(gap); // must be integer (avg gap in pixels)\n        config.fillWeight = parseFloat(weight.toFixed(precision)); // value is used in the sketched output as-is\n        // randomize double stroke effect if not explicitly set through user config\n        if (typeof config.disableMultiStroke === 'undefined') {\n            config.disableMultiStroke = context.rng.next() > 0.3;\n        }\n    }\n    return config;\n}\n/**\n * Converts SVG opacity attributes to a [0, 1] range.\n */\nexport function getOpacity(element, attribute) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const attr = getComputedStyle(element)[attribute] || element.getAttribute(attribute);\n    if (attr) {\n        if (attr.indexOf('%') !== -1) {\n            return Math.min(1, Math.max(0, parseFloat(attr.substring(0, attr.length - 1)) / 100));\n        }\n        return Math.min(1, Math.max(0, parseFloat(attr)));\n    }\n    return 1;\n}\n/**\n * Parses a `fill` url by looking in the SVG `defs` element.\n * When a gradient is found, it is converted to a color and stored\n * in the internal defs store for this url.\n *\n * Patterns are ignored and returned with 'none'.\n *\n * @returns The parsed color\n */\nexport function convertGradient(context, url, opacity) {\n    const id = getIdFromUrl(url);\n    if (!id) {\n        return 'none';\n    }\n    const paint = context.idElements[id];\n    if (!paint) {\n        return 'none';\n    }\n    if (typeof paint === 'string') {\n        // maybe it was already parsed and replaced with a color\n        return paint;\n    }\n    else if (paint instanceof SVGLinearGradientElement ||\n        paint instanceof SVGRadialGradientElement) {\n        const color = gradientToColor(paint, opacity);\n        context.idElements[id] = color;\n        return color;\n    }\n    else {\n        // pattern or something else that cannot be directly used in the roughjs config\n        return 'none';\n    }\n}\nexport function isHidden(element) {\n    const style = element.style;\n    if (!style) {\n        return false;\n    }\n    return style.display === 'none' || style.visibility === 'hidden';\n}\nexport function concatStyleStrings(...args) {\n    let ret = '';\n    args = args.filter(s => s !== null);\n    for (const style of args) {\n        if (ret.length > 0 && ret[ret.length - 1] !== ';') {\n            ret += ';';\n        }\n        ret += style;\n    }\n    return ret;\n}\n","export function str(p) {\n    return `${p.x},${p.y}`;\n}\nexport function equals(p0, p1) {\n    return p0.x === p1.x && p0.y === p1.y;\n}\n","import { getIdFromUrl } from '../dom-helpers';\nimport { getEffectiveAttribute } from '../styles/effective-attributes';\nimport { convertToPixelUnit } from '../svg-units';\nimport { equals } from './primitives';\nexport function drawMarkers(context, element, points, svgTransform) {\n    if (points.length === 0) {\n        return;\n    }\n    const startPt = points[0];\n    const endPt = points[points.length - 1];\n    // start marker\n    const markerStartId = getIdFromUrl(element.getAttribute('marker-start'));\n    const markerStartElement = markerStartId\n        ? context.idElements[markerStartId]\n        : null;\n    // marker-start is only rendered when there are at least two points\n    if (markerStartElement && points.length > 1) {\n        let angle = markerStartElement.orientAngle.baseVal.value;\n        const nextPt = points[1];\n        const orientAttr = markerStartElement.getAttribute('orient');\n        if (orientAttr === 'auto' || orientAttr === 'auto-start-reverse') {\n            const reverse = orientAttr === 'auto' ? 0 : 180;\n            const prevPt = points[points.length - 2];\n            if (isClosedPath(points)) {\n                // https://www.w3.org/TR/SVG11/painting.html#OrientAttribute\n                // use angle bisector of incoming and outgoing angle\n                angle = getBisectingAngle(prevPt, endPt, nextPt) - reverse;\n            }\n            else {\n                const vOut = { x: nextPt.x - startPt.x, y: nextPt.y - startPt.y };\n                angle = getAngle({ x: 1, y: 0 }, vOut) - reverse;\n            }\n        }\n        const matrix = context.sourceSvg\n            .createSVGMatrix()\n            .translate(startPt.x, startPt.y)\n            .rotate(angle)\n            .scale(getScaleFactor(context, markerStartElement, element));\n        const combinedMatrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;\n        const markerTransform = context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);\n        context.processElement(context, markerStartElement, markerTransform);\n    }\n    // end marker\n    const markerEndId = getIdFromUrl(element.getAttribute('marker-end'));\n    const markerEndElement = markerEndId\n        ? context.idElements[markerEndId]\n        : null;\n    // marker-end is also rendered if the path has only one point\n    if (markerEndElement) {\n        let angle = markerEndElement.orientAngle.baseVal.value;\n        if (points.length > 1) {\n            const orientAttr = markerEndElement.getAttribute('orient');\n            if (orientAttr === 'auto' || orientAttr === 'auto-start-reverse') {\n                // by spec, \"auto-start-reverse\" has no effect on marker end\n                const prevPt = points[points.length - 2];\n                if (isClosedPath(points)) {\n                    // https://www.w3.org/TR/SVG11/painting.html#OrientAttribute\n                    // use angle bisector of incoming and outgoing angle\n                    const nextPt = points[1]; // start and end points are equal, take second point\n                    angle = getBisectingAngle(prevPt, endPt, nextPt);\n                }\n                else {\n                    const vIn = { x: endPt.x - prevPt.x, y: endPt.y - prevPt.y };\n                    angle = getAngle({ x: 1, y: 0 }, vIn);\n                }\n            }\n        }\n        const matrix = context.sourceSvg\n            .createSVGMatrix()\n            .translate(endPt.x, endPt.y)\n            .rotate(angle)\n            .scale(getScaleFactor(context, markerEndElement, element));\n        const combinedMatrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;\n        const markerTransform = context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);\n        context.processElement(context, markerEndElement, markerTransform);\n    }\n    // mid marker(s)\n    const markerMidId = getIdFromUrl(element.getAttribute('marker-mid'));\n    const markerMidElement = markerMidId\n        ? context.idElements[markerMidId]\n        : null;\n    if (markerMidElement && points.length > 2) {\n        for (let i = 0; i < points.length; i++) {\n            const loc = points[i];\n            if (i === 0 || i === points.length - 1) {\n                // mid markers are not drawn on first or last point\n                continue;\n            }\n            let angle = markerMidElement.orientAngle.baseVal.value;\n            const orientAttr = markerMidElement.getAttribute('orient');\n            if (orientAttr === 'auto' || orientAttr === 'auto-start-reverse') {\n                // by spec, \"auto-start-reverse\" has no effect on marker mid\n                const prevPt = points[i - 1];\n                const nextPt = points[i + 1];\n                // https://www.w3.org/TR/SVG11/painting.html#OrientAttribute\n                // use angle bisector of incoming and outgoing angle\n                angle = getBisectingAngle(prevPt, loc, nextPt);\n            }\n            const matrix = context.sourceSvg\n                .createSVGMatrix()\n                .translate(loc.x, loc.y)\n                .rotate(angle)\n                .scale(getScaleFactor(context, markerMidElement, element));\n            const combinedMatrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;\n            const markerTransform = context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);\n            context.processElement(context, markerMidElement, markerTransform);\n        }\n    }\n}\n/**\n * Consider scaled coordinate system for markerWidth/markerHeight.\n */\nfunction getScaleFactor(context, marker, referrer) {\n    const markerUnits = marker.getAttribute('markerUnits');\n    let scaleFactor = 1;\n    if (!markerUnits || markerUnits === 'strokeWidth') {\n        // default is strokeWidth by SVG spec\n        const strokeWidth = getEffectiveAttribute(context, referrer, 'stroke-width');\n        if (strokeWidth) {\n            scaleFactor = convertToPixelUnit(context, referrer, strokeWidth, 'stroke-width');\n        }\n    }\n    return scaleFactor;\n}\n/**\n * Whether the path is closed, i.e. the start and end points are identical\n */\nfunction isClosedPath(points) {\n    return equals(points[0], points[points.length - 1]);\n}\n/**\n * Returns the bisection angle of the angle that is spanned by the given points.\n * @param prevPt The point from which the incoming flank is pointing\n * @param crossingPt The anchor point of the angle\n * @param nextPt Th point to which the outgoing flank is pointing\n * @returns The bisecting angle\n */\nfunction getBisectingAngle(prevPt, crossingPt, nextPt) {\n    const vIn = { x: nextPt.x - crossingPt.x, y: nextPt.y - crossingPt.y };\n    const vOut = { x: prevPt.x - crossingPt.x, y: prevPt.y - crossingPt.y };\n    // the relative angle between the two vectors\n    const vectorAngle = getAngle(vIn, vOut);\n    // calculate the absolute angle of the vectors considering the x-axis as reference\n    const refPoint = { x: crossingPt.x + 1, y: crossingPt.y };\n    const refVector = { x: refPoint.x - crossingPt.x, y: refPoint.y - crossingPt.y };\n    const refAngle = getAngle(vIn, refVector);\n    // return the absolute bisector\n    return getOppositeAngle(vectorAngle) / 2 - refAngle;\n}\n/**\n * Returns the opposite angle of the line. Considers the direction of the angle\n * (i.e. positive for clockwise, negative for counter-clickwise).\n */\nfunction getOppositeAngle(angle) {\n    return angle - Math.sign(angle) * 180;\n}\n/**\n * Returns the signed angle between the vectors (i.e. positive for clockwise,\n * negative for counter-clickwise).\n * @param v1 2-dimensional vector\n * @param v2 2-dimensional vector\n * @returns The signed angle between the vectors\n */\nfunction getAngle(v1, v2) {\n    const a1 = Math.atan2(v1.y, v1.x);\n    const a2 = Math.atan2(v2.y, v2.x);\n    const angle = a2 - a1;\n    const K = -Math.sign(angle) * Math.PI * 2;\n    const a = Math.abs(K + angle) < Math.abs(angle) ? K + angle : angle;\n    return Math.round((360 * a) / (Math.PI * 2));\n}\n","import { appendPatternPaint } from '../styles/pattern';\nimport { parseStyleConfig } from '../styles/styles';\nimport { applyTransform, applyMatrix, isIdentityTransform, isTranslationTransform } from '../transformation';\nimport { appendSketchElement, sketchPath } from '../utils';\nimport { str } from './primitives';\nexport function drawRect(context, rect, svgTransform) {\n    const x = rect.x.baseVal.value;\n    const y = rect.y.baseVal.value;\n    const width = rect.width.baseVal.value;\n    const height = rect.height.baseVal.value;\n    if (width === 0 || height === 0) {\n        // zero-width or zero-height rect will not be rendered\n        return;\n    }\n    // Negative values are an error and result in the default value, and clamp both values to half their sides' lengths\n    let rx = rect.hasAttribute('rx') ? Math.min(Math.max(0, rect.rx.baseVal.value), width / 2) : null;\n    let ry = rect.hasAttribute('ry') ? Math.min(Math.max(0, rect.ry.baseVal.value), height / 2) : null;\n    if (rx !== null || ry !== null) {\n        // If only one of the two values is specified, the other has the same value\n        rx = rx === null ? ry : rx;\n        ry = ry === null ? rx : ry;\n    }\n    // the transformed, rectangular bounds\n    const p1 = applyMatrix({ x, y }, svgTransform);\n    const p2 = applyMatrix({ x: x + width, y: y + height }, svgTransform);\n    const transformedWidth = p2.x - p1.x;\n    const transformedHeight = p2.y - p1.y;\n    const transformedBounds = { x: p1.x, y: p1.y, w: transformedWidth, h: transformedHeight };\n    if ((isIdentityTransform(svgTransform) || isTranslationTransform(svgTransform)) && !rx && !ry) {\n        // Simple case; just a rectangle\n        const sketchRect = context.rc.rectangle(transformedBounds.x, transformedBounds.y, transformedBounds.w, transformedBounds.h, parseStyleConfig(context, rect, svgTransform));\n        applyPatternPaint(context, rect, transformedBounds);\n        appendSketchElement(context, rect, sketchRect);\n    }\n    else {\n        let path = '';\n        if (rx !== null && ry !== null) {\n            const factor = (4 / 3) * (Math.sqrt(2) - 1);\n            // Construct path for the rounded rectangle\n            // perform an absolute moveto operation to location (x+rx,y), where x is the value of the ‘rect’ element's ‘x’ attribute converted to user space, rx is the effective value of the ‘rx’ attribute converted to user space and y is the value of the ‘y’ attribute converted to user space\n            const p1 = applyMatrix({ x: x + rx, y }, svgTransform);\n            path += `M ${str(p1)}`;\n            // perform an absolute horizontal lineto operation to location (x+width-rx,y), where width is the ‘rect’ element's ‘width’ attribute converted to user space\n            const p2 = applyMatrix({ x: x + width - rx, y }, svgTransform);\n            path += `L ${str(p2)}`;\n            // perform an absolute elliptical arc operation to coordinate (x+width,y+ry), where the effective values for the ‘rx’ and ‘ry’ attributes on the ‘rect’ element converted to user space are used as the rx and ry attributes on the elliptical arc command, respectively, the x-axis-rotation is set to zero, the large-arc-flag is set to zero, and the sweep-flag is set to one\n            const p3c1 = applyMatrix({ x: x + width - rx + factor * rx, y }, svgTransform);\n            const p3c2 = applyMatrix({ x: x + width, y: y + factor * ry }, svgTransform);\n            const p3 = applyMatrix({ x: x + width, y: y + ry }, svgTransform);\n            path += `C ${str(p3c1)} ${str(p3c2)} ${str(p3)}`; // We cannot use the arc command, since we no longer draw in the expected coordinates. So approximate everything with lines and béziers\n            // perform a absolute vertical lineto to location (x+width,y+height-ry), where height is the ‘rect’ element's ‘height’ attribute converted to user space\n            const p4 = applyMatrix({ x: x + width, y: y + height - ry }, svgTransform);\n            path += `L ${str(p4)}`;\n            // perform an absolute elliptical arc operation to coordinate (x+width-rx,y+height)\n            const p5c1 = applyMatrix({ x: x + width, y: y + height - ry + factor * ry }, svgTransform);\n            const p5c2 = applyMatrix({ x: x + width - factor * rx, y: y + height }, svgTransform);\n            const p5 = applyMatrix({ x: x + width - rx, y: y + height }, svgTransform);\n            path += `C ${str(p5c1)} ${str(p5c2)} ${str(p5)}`;\n            // perform an absolute horizontal lineto to location (x+rx,y+height)\n            const p6 = applyMatrix({ x: x + rx, y: y + height }, svgTransform);\n            path += `L ${str(p6)}`;\n            // perform an absolute elliptical arc operation to coordinate (x,y+height-ry)\n            const p7c1 = applyMatrix({ x: x + rx - factor * rx, y: y + height }, svgTransform);\n            const p7c2 = applyMatrix({ x, y: y + height - factor * ry }, svgTransform);\n            const p7 = applyMatrix({ x, y: y + height - ry }, svgTransform);\n            path += `C ${str(p7c1)} ${str(p7c2)} ${str(p7)}`;\n            // perform an absolute absolute vertical lineto to location (x,y+ry)\n            const p8 = applyMatrix({ x, y: y + ry }, svgTransform);\n            path += `L ${str(p8)}`;\n            // perform an absolute elliptical arc operation to coordinate (x+rx,y)\n            const p9c1 = applyMatrix({ x, y: y + factor * ry }, svgTransform);\n            const p9c2 = applyMatrix({ x: x + factor * rx, y }, svgTransform);\n            path += `C ${str(p9c1)} ${str(p9c2)} ${str(p1)}`;\n            path += 'z';\n        }\n        else {\n            // No rounding, so just construct the respective path as a simple polygon\n            const p1 = applyMatrix({ x, y }, svgTransform);\n            const p2 = applyMatrix({ x: x + width, y }, svgTransform);\n            const p3 = applyMatrix({ x: x + width, y: y + height }, svgTransform);\n            const p4 = applyMatrix({ x, y: y + height }, svgTransform);\n            path += `M ${str(p1)}`;\n            path += `L ${str(p2)}`;\n            path += `L ${str(p3)}`;\n            path += `L ${str(p4)}`;\n            path += `z`;\n        }\n        const result = sketchPath(context, path, parseStyleConfig(context, rect, svgTransform));\n        applyPatternPaint(context, rect, transformedBounds);\n        appendSketchElement(context, rect, result);\n    }\n}\nfunction applyPatternPaint(context, rect, { x, y, w, h }) {\n    appendPatternPaint(context, rect, () => {\n        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        proxy.x.baseVal.value = x;\n        proxy.y.baseVal.value = y;\n        proxy.width.baseVal.value = w;\n        proxy.height.baseVal.value = h;\n        return proxy;\n    });\n}\nexport function applyRectClip(context, rect, container, svgTransform) {\n    const x = rect.x.baseVal.value;\n    const y = rect.y.baseVal.value;\n    const width = rect.width.baseVal.value;\n    const height = rect.height.baseVal.value;\n    if (width === 0 || height === 0) {\n        // zero-width or zero-height rect will not be rendered\n        return;\n    }\n    const rx = rect.hasAttribute('rx') ? rect.rx.baseVal.value : null;\n    const ry = rect.hasAttribute('ry') ? rect.ry.baseVal.value : null;\n    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    clip.x.baseVal.value = x;\n    clip.y.baseVal.value = y;\n    clip.width.baseVal.value = width;\n    clip.height.baseVal.value = height;\n    if (rx) {\n        clip.rx.baseVal.value = rx;\n    }\n    if (ry) {\n        clip.ry.baseVal.value = ry;\n    }\n    applyTransform(context, svgTransform, clip);\n    container.appendChild(clip);\n}\n","import { getIdFromUrl, getNodeChildren } from './dom-helpers';\nimport { applyCircleClip } from './geom/circle';\nimport { applyEllipseClip } from './geom/ellipse';\nimport { applyPathClip } from './geom/path';\nimport { applyPolygonClip } from './geom/polygon';\nimport { applyRectClip } from './geom/rect';\nimport { getCombinedTransform } from './transformation';\nimport { getDefsElement, SKETCH_CLIP_ATTRIBUTE } from './utils';\n/**\n * Applies the clip-path to the CanvasContext.\n */\nexport function applyClipPath(context, owner, clipPathAttr, svgTransform) {\n    const id = getIdFromUrl(clipPathAttr);\n    if (!id) {\n        return;\n    }\n    const clipPath = context.idElements[id];\n    if (!clipPath) {\n        return;\n    }\n    // TODO clipPath: consider clipPathUnits\n    //  create clipPath defs\n    const targetDefs = getDefsElement(context);\n    // unfortunately, we cannot reuse clip-paths due to the 'global transform' approach\n    const sketchClipPathId = `${id}_${targetDefs.childElementCount}`;\n    const clipContainer = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');\n    clipContainer.id = sketchClipPathId;\n    storeSketchClipId(owner, sketchClipPathId);\n    // traverse clip-path elements in DFS\n    const stack = [];\n    const children = getNodeChildren(clipPath);\n    for (let i = children.length - 1; i >= 0; i--) {\n        const childElement = children[i];\n        const childTransform = getCombinedTransform(context, childElement, svgTransform);\n        stack.push({ element: childElement, transform: childTransform });\n    }\n    while (stack.length > 0) {\n        const { element, transform } = stack.pop();\n        try {\n            applyElementClip(context, element, clipContainer, transform);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (element.tagName === 'defs' ||\n            element.tagName === 'svg' ||\n            element.tagName === 'clipPath' ||\n            element.tagName === 'text') {\n            // some elements are ignored on clippaths\n            continue;\n        }\n        // process children\n        const children = getNodeChildren(element);\n        for (let i = children.length - 1; i >= 0; i--) {\n            const childElement = children[i];\n            const childTransform = getCombinedTransform(context, childElement, transform);\n            stack.push({ element: childElement, transform: childTransform });\n        }\n    }\n    if (clipContainer.childNodes.length > 0) {\n        // add the clip-path only if it contains converted elements\n        // some elements are not yet supported\n        targetDefs.appendChild(clipContainer);\n    }\n}\n/**\n * Creates a clip element and appends it to the given container.\n */\nfunction applyElementClip(context, element, container, svgTransform) {\n    switch (element.tagName) {\n        case 'rect':\n            applyRectClip(context, element, container, svgTransform);\n            break;\n        case 'circle':\n            applyCircleClip(context, element, container, svgTransform);\n            break;\n        case 'ellipse':\n            applyEllipseClip(context, element, container, svgTransform);\n            break;\n        case 'polygon':\n            applyPolygonClip(context, element, container, svgTransform);\n            break;\n        case 'path':\n            applyPathClip(context, element, container, svgTransform);\n            break;\n    }\n}\n/**\n * Store clippath-id on each child for <g> elements, or on the owner itself for other\n * elements.\n *\n * <g> elements are skipped in the processing loop, thus the clip-path id must be stored\n * on the child elements.\n */\nfunction storeSketchClipId(element, id) {\n    if (element.tagName !== 'g') {\n        element.setAttribute(SKETCH_CLIP_ATTRIBUTE, id);\n        return;\n    }\n    const stack = [];\n    const children = getNodeChildren(element);\n    for (let i = children.length - 1; i >= 0; i--) {\n        stack.push(children[i]);\n    }\n    while (stack.length > 0) {\n        const element = stack.pop();\n        element.setAttribute(SKETCH_CLIP_ATTRIBUTE, id);\n        const children = getNodeChildren(element);\n        for (let i = children.length - 1; i >= 0; i--) {\n            stack.push(children[i]);\n        }\n    }\n}\n","import { appendPatternPaint } from '../styles/pattern';\nimport { parseStyleConfig } from '../styles/styles';\nimport { applyTransform, applyMatrix, isIdentityTransform, isTranslationTransform } from '../transformation';\nimport { appendSketchElement, sketchPath } from '../utils';\nimport { str } from './primitives';\nexport function drawCircle(context, circle, svgTransform) {\n    const cx = circle.cx.baseVal.value;\n    const cy = circle.cy.baseVal.value;\n    const r = circle.r.baseVal.value;\n    if (r === 0) {\n        // zero-radius circle is not rendered\n        return;\n    }\n    const center = applyMatrix({ x: cx, y: cy }, svgTransform);\n    const radiusPoint = applyMatrix({ x: cx + r, y: cy + r }, svgTransform);\n    const transformedRadius = radiusPoint.x - center.x;\n    let result;\n    if (isIdentityTransform(svgTransform) || isTranslationTransform(svgTransform)) {\n        // transform a point on the ellipse to get the transformed radius\n        result = context.rc.circle(center.x, center.y, 2 * transformedRadius, Object.assign(Object.assign({}, parseStyleConfig(context, circle, svgTransform)), { preserveVertices: true }));\n    }\n    else {\n        // in other cases we need to construct the path manually.\n        const factor = (4 / 3) * (Math.sqrt(2) - 1);\n        const p1 = applyMatrix({ x: cx + r, y: cy }, svgTransform);\n        const p2 = applyMatrix({ x: cx, y: cy + r }, svgTransform);\n        const p3 = applyMatrix({ x: cx - r, y: cy }, svgTransform);\n        const p4 = applyMatrix({ x: cx, y: cy - r }, svgTransform);\n        const c1 = applyMatrix({ x: cx + r, y: cy + factor * r }, svgTransform);\n        const c2 = applyMatrix({ x: cx + factor * r, y: cy + r }, svgTransform);\n        const c4 = applyMatrix({ x: cx - r, y: cy + factor * r }, svgTransform);\n        const c6 = applyMatrix({ x: cx - factor * r, y: cy - r }, svgTransform);\n        const c8 = applyMatrix({ x: cx + r, y: cy - factor * r }, svgTransform);\n        const path = `M ${str(p1)} C ${str(c1)} ${str(c2)} ${str(p2)} S ${str(c4)} ${str(p3)} S ${str(c6)} ${str(p4)} S ${str(c8)} ${str(p1)}z`;\n        result = sketchPath(context, path, parseStyleConfig(context, circle, svgTransform));\n    }\n    appendPatternPaint(context, circle, () => {\n        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n        proxy.cx.baseVal.value = center.x;\n        proxy.cy.baseVal.value = center.y;\n        proxy.r.baseVal.value = transformedRadius;\n        return proxy;\n    });\n    appendSketchElement(context, circle, result);\n}\nexport function applyCircleClip(context, circle, container, svgTransform) {\n    const cx = circle.cx.baseVal.value;\n    const cy = circle.cy.baseVal.value;\n    const r = circle.r.baseVal.value;\n    if (r === 0) {\n        // zero-radius circle is not rendered\n        return;\n    }\n    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n    clip.cx.baseVal.value = cx;\n    clip.cy.baseVal.value = cy;\n    clip.r.baseVal.value = r;\n    applyTransform(context, svgTransform, clip);\n    container.appendChild(clip);\n}\n","import { appendPatternPaint } from '../styles/pattern';\nimport { parseStyleConfig } from '../styles/styles';\nimport { applyTransform, applyMatrix, isIdentityTransform, isTranslationTransform } from '../transformation';\nimport { appendSketchElement, sketchPath } from '../utils';\nimport { str } from './primitives';\nexport function drawEllipse(context, ellipse, svgTransform) {\n    const cx = ellipse.cx.baseVal.value;\n    const cy = ellipse.cy.baseVal.value;\n    const rx = ellipse.rx.baseVal.value;\n    const ry = ellipse.ry.baseVal.value;\n    if (rx === 0 || ry === 0) {\n        // zero-radius ellipse is not rendered\n        return;\n    }\n    const center = applyMatrix({ x: cx, y: cy }, svgTransform);\n    // transform a point on the ellipse to get the transformed radius\n    const radiusPoint = applyMatrix({ x: cx + rx, y: cy + ry }, svgTransform);\n    const transformedRx = radiusPoint.x - center.x;\n    const transformedRy = radiusPoint.y - center.y;\n    let result;\n    if (isIdentityTransform(svgTransform) || isTranslationTransform(svgTransform)) {\n        // Simple case, there's no transform and we can use the ellipse command\n        result = context.rc.ellipse(center.x, center.y, 2 * transformedRx, 2 * transformedRy, Object.assign(Object.assign({}, parseStyleConfig(context, ellipse, svgTransform)), { preserveVertices: true }));\n    }\n    else {\n        // in other cases we need to construct the path manually.\n        const factor = (4 / 3) * (Math.sqrt(2) - 1);\n        const p1 = applyMatrix({ x: cx + rx, y: cy }, svgTransform);\n        const p2 = applyMatrix({ x: cx, y: cy + ry }, svgTransform);\n        const p3 = applyMatrix({ x: cx - rx, y: cy }, svgTransform);\n        const p4 = applyMatrix({ x: cx, y: cy - ry }, svgTransform);\n        const c1 = applyMatrix({ x: cx + rx, y: cy + factor * ry }, svgTransform);\n        const c2 = applyMatrix({ x: cx + factor * rx, y: cy + ry }, svgTransform);\n        const c4 = applyMatrix({ x: cx - rx, y: cy + factor * ry }, svgTransform);\n        const c6 = applyMatrix({ x: cx - factor * rx, y: cy - ry }, svgTransform);\n        const c8 = applyMatrix({ x: cx + rx, y: cy - factor * ry }, svgTransform);\n        const path = `M ${str(p1)} C ${str(c1)} ${str(c2)} ${str(p2)} S ${str(c4)} ${str(p3)} S ${str(c6)} ${str(p4)} S ${str(c8)} ${str(p1)}z`;\n        result = sketchPath(context, path, parseStyleConfig(context, ellipse, svgTransform));\n    }\n    appendPatternPaint(context, ellipse, () => {\n        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');\n        proxy.cx.baseVal.value = center.x;\n        proxy.cy.baseVal.value = center.y;\n        proxy.rx.baseVal.value = transformedRx;\n        proxy.ry.baseVal.value = transformedRy;\n        return proxy;\n    });\n    appendSketchElement(context, ellipse, result);\n}\nexport function applyEllipseClip(context, ellipse, container, svgTransform) {\n    const cx = ellipse.cx.baseVal.value;\n    const cy = ellipse.cy.baseVal.value;\n    const rx = ellipse.rx.baseVal.value;\n    const ry = ellipse.ry.baseVal.value;\n    if (rx === 0 || ry === 0) {\n        // zero-radius ellipse is not rendered\n        return;\n    }\n    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');\n    clip.cx.baseVal.value = cx;\n    clip.cy.baseVal.value = cy;\n    clip.rx.baseVal.value = rx;\n    clip.ry.baseVal.value = ry;\n    applyTransform(context, svgTransform, clip);\n    container.appendChild(clip);\n}\n","import { appendPatternPaint } from '../styles/pattern';\nimport { parseStyleConfig } from '../styles/styles';\nimport { applyTransform, applyMatrix } from '../transformation';\nimport { appendSketchElement, getPointsArray } from '../utils';\nimport { drawMarkers } from './marker';\nexport function drawPolygon(context, polygon, svgTransform) {\n    const points = getPointsArray(polygon);\n    const transformed = points.map(p => {\n        const pt = applyMatrix(p, svgTransform);\n        return [pt.x, pt.y];\n    });\n    const polygonSketch = context.rc.polygon(transformed, parseStyleConfig(context, polygon, svgTransform));\n    appendPatternPaint(context, polygon, () => {\n        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n        proxy.setAttribute('points', transformed.join(' '));\n        return proxy;\n    });\n    appendSketchElement(context, polygon, polygonSketch);\n    // https://www.w3.org/TR/SVG11/painting.html#MarkerProperties\n    // Note that for a ‘path’ element which ends with a closed sub-path,\n    // the last vertex is the same as the initial vertex on the given\n    // sub-path (same applies to polygon).\n    if (points.length > 0) {\n        points.push(points[0]);\n        drawMarkers(context, polygon, points, svgTransform);\n    }\n}\nexport function applyPolygonClip(context, polygon, container, svgTransform) {\n    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n    clip.setAttribute('points', polygon.getAttribute('points'));\n    applyTransform(context, svgTransform, clip);\n    container.appendChild(clip);\n}\n","import { encodeSVGPath, SVGPathData, SVGPathDataTransformer } from 'svg-pathdata';\nimport { appendPatternPaint } from '../styles/pattern';\nimport { parseStyleConfig } from '../styles/styles';\nimport { applyTransform } from '../transformation';\nimport { appendSketchElement, sketchPath } from '../utils';\nimport { drawMarkers } from './marker';\nexport function drawPath(context, path, svgTransform) {\n    const dataAttrs = path.getAttribute('d');\n    const pathData = \n    // Parse path data and convert to absolute coordinates\n    new SVGPathData(dataAttrs)\n        .toAbs()\n        // Normalize H and V to L commands - those cannot work with how we draw transformed paths otherwise\n        .transform(SVGPathDataTransformer.NORMALIZE_HVZ())\n        // Normalize S and T to Q and C commands - Rough.js has a bug with T where it expects 4 parameters instead of 2\n        .transform(SVGPathDataTransformer.NORMALIZE_ST());\n    // If there's a transform, transform the whole path accordingly\n    const transformedPathData = new SVGPathData(\n    // clone the commands, we might need them untransformed for markers\n    pathData.commands.map(cmd => Object.assign({}, cmd)));\n    if (svgTransform) {\n        transformedPathData.transform(SVGPathDataTransformer.MATRIX(svgTransform.matrix.a, svgTransform.matrix.b, svgTransform.matrix.c, svgTransform.matrix.d, svgTransform.matrix.e, svgTransform.matrix.f));\n    }\n    const encodedPathData = encodeSVGPath(transformedPathData.commands);\n    if (encodedPathData.indexOf('undefined') !== -1) {\n        // DEBUG STUFF\n        console.error('broken path data');\n        return;\n    }\n    const pathSketch = sketchPath(context, encodedPathData, parseStyleConfig(context, path, svgTransform));\n    appendPatternPaint(context, path, () => {\n        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n        proxy.setAttribute('d', encodedPathData);\n        return proxy;\n    });\n    appendSketchElement(context, path, pathSketch);\n    // https://www.w3.org/TR/SVG11/painting.html#MarkerProperties\n    // Note that for a ‘path’ element which ends with a closed sub-path,\n    // the last vertex is the same as the initial vertex on the given\n    // sub-path (same applies to polygon).\n    const points = [];\n    let currentSubPathBegin;\n    pathData.commands.forEach(cmd => {\n        switch (cmd.type) {\n            case SVGPathData.MOVE_TO: {\n                const p = { x: cmd.x, y: cmd.y };\n                points.push(p);\n                // each moveto starts a new subpath\n                currentSubPathBegin = p;\n                break;\n            }\n            case SVGPathData.LINE_TO:\n            case SVGPathData.QUAD_TO:\n            case SVGPathData.SMOOTH_QUAD_TO:\n            case SVGPathData.CURVE_TO:\n            case SVGPathData.SMOOTH_CURVE_TO:\n            case SVGPathData.ARC:\n                points.push({ x: cmd.x, y: cmd.y });\n                break;\n            case SVGPathData.HORIZ_LINE_TO:\n                points.push({ x: cmd.x, y: 0 });\n                break;\n            case SVGPathData.VERT_LINE_TO:\n                points.push({ x: 0, y: cmd.y });\n                break;\n            case SVGPathData.CLOSE_PATH:\n                if (currentSubPathBegin) {\n                    points.push(currentSubPathBegin);\n                }\n                break;\n        }\n    });\n    drawMarkers(context, path, points, svgTransform);\n}\nexport function applyPathClip(context, path, container, svgTransform) {\n    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    clip.setAttribute('d', path.getAttribute('d'));\n    applyTransform(context, svgTransform, clip);\n    container.appendChild(clip);\n}\n","import { getNodeChildren } from '../dom-helpers';\nimport { getEffectiveAttribute } from '../styles/effective-attributes';\nimport { concatStyleStrings } from '../styles/styles';\nimport { convertToPixelUnit } from '../svg-units';\nimport { applyTransform } from '../transformation';\nimport { SKETCH_CLIP_ATTRIBUTE, appendSketchElement, measureText } from '../utils';\nexport function drawText(context, text, svgTransform) {\n    const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    container.setAttribute('class', 'text-container');\n    applyTransform(context, svgTransform, container);\n    const textClone = text.cloneNode(true);\n    if (textClone.transform.baseVal.numberOfItems > 0) {\n        // remove transformation, since it is transformed globally by its parent container\n        textClone.transform.baseVal.clear();\n    }\n    // clip-path is applied on the container\n    textClone.removeAttribute('clip-path');\n    const { cssFont, fontSize: effectiveFontSize } = getCssFont(context, text, true);\n    textClone.setAttribute('style', concatStyleStrings(textClone.getAttribute('style'), cssFont));\n    copyTextStyleAttributes(context, text, textClone);\n    // apply styling to any tspan\n    if (textClone.childElementCount > 0) {\n        const children = getNodeChildren(textClone);\n        const origChildren = getNodeChildren(text);\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child instanceof SVGTSpanElement) {\n                copyTextStyleAttributes(context, origChildren[i], child);\n            }\n        }\n    }\n    container.appendChild(textClone);\n    appendSketchElement(context, text, container);\n    // avoid text clipping by scaling the text when changing the font\n    const useCustomFontFamily = context.fontFamily !== null;\n    const hasClipPath = textClone.hasAttribute(SKETCH_CLIP_ATTRIBUTE);\n    if (useCustomFontFamily && hasClipPath && effectiveFontSize) {\n        fitFontSize(context, text, textClone, effectiveFontSize);\n    }\n}\n/**\n * Applies a font-size on the clone such that the clone has a smaller width than the original element.\n * Only fits the width because the height is usually no problem wrt. clipping.\n */\nfunction fitFontSize(context, original, clone, effectiveFontSize) {\n    const { width, height } = original.getBBox();\n    if (width <= 0 || height <= 0) {\n        return;\n    }\n    const fontSizePx = convertToPixelUnit(context, clone, effectiveFontSize, 'font-size');\n    fitFontSizeCore(context, { w: width, h: height }, clone, fontSizePx);\n}\n/**\n * Recursively shrinks the font-size on the element until its width is smaller than the original width.\n */\nfunction fitFontSizeCore(context, originalSize, clone, fontSizePx) {\n    const STEP_SIZE = 1;\n    const { w: cloneWidth } = measureText(context, clone);\n    if (cloneWidth < originalSize.w) {\n        // fits original width\n        return;\n    }\n    if (fontSizePx <= 1) {\n        // already too small\n        return;\n    }\n    // try a smaller size\n    const newFontSize = fontSizePx - STEP_SIZE;\n    clone.style.fontSize = `${newFontSize}px`;\n    // check again\n    fitFontSizeCore(context, originalSize, clone, newFontSize);\n}\n/**\n * @param asStyleString Formats the return value as inline style string\n */\nfunction getCssFont(context, text, asStyleString = false) {\n    const effectiveAttributes = {};\n    let cssFont = '';\n    const fontStyle = getEffectiveAttribute(context, text, 'font-style', context.useElementContext);\n    if (fontStyle) {\n        cssFont += asStyleString ? `font-style: ${fontStyle};` : fontStyle;\n        effectiveAttributes.fontStyle = fontStyle;\n    }\n    const fontWeight = getEffectiveAttribute(context, text, 'font-weight', context.useElementContext);\n    if (fontWeight) {\n        cssFont += asStyleString ? `font-weight: ${fontWeight};` : ` ${fontWeight}`;\n        effectiveAttributes.fontWeight = fontWeight;\n    }\n    const fontSize = getEffectiveAttribute(context, text, 'font-size', context.useElementContext);\n    if (fontSize) {\n        cssFont += asStyleString ? `font-size: ${fontSize};` : ` ${fontSize}`;\n        effectiveAttributes.fontSize = fontSize;\n    }\n    if (context.fontFamily) {\n        cssFont += asStyleString ? `font-family: ${context.fontFamily};` : ` ${context.fontFamily}`;\n        effectiveAttributes.fontFamiliy = context.fontFamily;\n    }\n    else {\n        const fontFamily = getEffectiveAttribute(context, text, 'font-family', context.useElementContext);\n        if (fontFamily) {\n            cssFont += asStyleString ? `font-family: ${fontFamily};` : ` ${fontFamily}`;\n            effectiveAttributes.fontFamiliy = fontFamily;\n        }\n    }\n    cssFont = cssFont.trim();\n    return Object.assign(Object.assign({}, effectiveAttributes), { cssFont });\n}\nfunction copyTextStyleAttributes(context, srcElement, tgtElement) {\n    const stroke = getEffectiveAttribute(context, srcElement, 'stroke');\n    const strokeWidth = stroke ? getEffectiveAttribute(context, srcElement, 'stroke-width') : null;\n    const fill = getEffectiveAttribute(context, srcElement, 'fill');\n    const dominantBaseline = getEffectiveAttribute(context, srcElement, 'dominant-baseline');\n    const textAnchor = getEffectiveAttribute(context, srcElement, 'text-anchor', context.useElementContext);\n    if (stroke) {\n        tgtElement.setAttribute('stroke', stroke);\n    }\n    if (strokeWidth) {\n        tgtElement.setAttribute('stroke-width', strokeWidth);\n    }\n    if (fill) {\n        tgtElement.setAttribute('fill', fill);\n    }\n    if (textAnchor) {\n        tgtElement.setAttribute('text-anchor', textAnchor);\n    }\n    if (dominantBaseline) {\n        tgtElement.setAttribute('dominant-baseline', dominantBaseline);\n    }\n}\n","import { applyClipPath } from './clipping';\nimport { getNodeChildren } from './dom-helpers';\nimport { drawCircle } from './geom/circle';\nimport { drawEllipse } from './geom/ellipse';\nimport { drawForeignObject } from './geom/foreign-object';\nimport { drawImage } from './geom/image';\nimport { drawLine } from './geom/line';\nimport { drawPath } from './geom/path';\nimport { drawPolygon } from './geom/polygon';\nimport { drawPolyline } from './geom/polyline';\nimport { drawRect } from './geom/rect';\nimport { drawText } from './geom/text';\nimport { drawUse } from './geom/use';\nimport { isHidden } from './styles/styles';\nimport { getCombinedTransform } from './transformation';\n/**\n * Traverses the SVG in DFS and draws each element to the canvas.\n * @param root either an SVG- or g-element\n * @param width Use elements can overwrite width\n * @param height Use elements can overwrite height\n */\nexport function processRoot(context, root, svgTransform, width, height) {\n    var _a, _b;\n    // traverse svg in DFS\n    const stack = [];\n    const currentViewBox = { x: 0, y: 0, w: width !== null && width !== void 0 ? width : 0, h: height !== null && height !== void 0 ? height : 0 };\n    if (root instanceof SVGSVGElement ||\n        root instanceof SVGSymbolElement ||\n        root instanceof SVGMarkerElement) {\n        let rootX = 0;\n        let rootY = 0;\n        if (root instanceof SVGSymbolElement) {\n            rootX = parseFloat((_a = root.getAttribute('x')) !== null && _a !== void 0 ? _a : '') || 0;\n            rootY = parseFloat((_b = root.getAttribute('y')) !== null && _b !== void 0 ? _b : '') || 0;\n            width = width !== null && width !== void 0 ? width : (parseFloat(root.getAttribute('width')) || void 0);\n            height = height !== null && height !== void 0 ? height : (parseFloat(root.getAttribute('height')) || void 0);\n        }\n        else if (root instanceof SVGMarkerElement) {\n            // markers use refX / refY which is applied after user-space transformation\n            const mw = root.getAttribute('markerWidth');\n            const mh = root.getAttribute('markerHeight');\n            width = mw !== null ? parseFloat(mw) : 3; // marker-size is 3 by SVG spec\n            height = mh !== null ? parseFloat(mh) : 3;\n        }\n        else if (root !== context.sourceSvg) {\n            // apply translation of nested elements\n            rootX = root.x.baseVal.value;\n            rootY = root.y.baseVal.value;\n        }\n        let rootTransform = context.sourceSvg.createSVGMatrix();\n        if (root.getAttribute('viewBox')) {\n            const { x: viewBoxX, y: viewBoxY, width: viewBoxWidth, height: viewBoxHeight } = root.viewBox.baseVal;\n            currentViewBox.x = viewBoxX;\n            currentViewBox.y = viewBoxY;\n            currentViewBox.w = viewBoxWidth;\n            currentViewBox.h = viewBoxHeight;\n            if (typeof width !== 'undefined' && typeof height !== 'undefined') {\n                // viewBox values might scale the SVGs content\n                const sx = width / viewBoxWidth;\n                const sy = height / viewBoxHeight;\n                const centerviewportX = rootX + width * 0.5;\n                const centerviewportY = rootY + height * 0.5;\n                const centerViewBoxX = viewBoxX + viewBoxWidth * 0.5;\n                const centerViewBoxY = viewBoxY + viewBoxHeight * 0.5;\n                // only support scaling from the center, e.g. xMidYMid\n                rootTransform = rootTransform.translate(centerviewportX, centerviewportY);\n                if (root.getAttribute('preserveAspectRatio') === 'none') {\n                    rootTransform = rootTransform.scaleNonUniform(sx, sy);\n                }\n                else {\n                    rootTransform = rootTransform.scale(Math.min(sx, sy));\n                }\n                rootTransform = rootTransform.translate(-centerViewBoxX, -centerViewBoxY);\n            }\n        }\n        else {\n            rootTransform = rootTransform.translate(rootX, rootY);\n        }\n        if (root instanceof SVGMarkerElement) {\n            // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/refX#symbol\n            // ref coordinates are interpreted as being in the coordinate system of the element contents,\n            // after application of the viewBox and preserveAspectRatio attributes.\n            rootTransform = rootTransform.translate(-root.refX.baseVal.value, -root.refY.baseVal.value);\n        }\n        const combinedMatrix = svgTransform\n            ? svgTransform.matrix.multiply(rootTransform)\n            : rootTransform;\n        svgTransform = context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);\n        // don't put the SVG itself into the stack, so start with the children of it\n        const children = getNodeChildren(root);\n        for (let i = children.length - 1; i >= 0; i--) {\n            const child = children[i];\n            if (child instanceof SVGSymbolElement || child instanceof SVGMarkerElement) {\n                // symbols and marker can only be instantiated by specific elements\n                continue;\n            }\n            const childTransform = getCombinedTransform(context, child, svgTransform);\n            stack.push({ element: child, transform: childTransform, viewBox: currentViewBox });\n        }\n    }\n    else {\n        stack.push({ element: root, transform: svgTransform, viewBox: currentViewBox });\n    }\n    while (stack.length > 0) {\n        const { element, transform, viewBox } = stack.pop();\n        // maybe draw the element\n        try {\n            context.viewBox = viewBox;\n            drawElement(context, element, transform);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (element.tagName === 'defs' ||\n            element.tagName === 'symbol' ||\n            element.tagName === 'marker' ||\n            element.tagName === 'svg' ||\n            element.tagName === 'clipPath') {\n            // Defs are prepocessed separately.\n            // Symbols and marker can only be instantiated by specific elements.\n            // Don't traverse the SVG element itself. This is done by drawElement -> processRoot.\n            // ClipPaths are not drawn and processed separately.\n            continue;\n        }\n        // process children\n        const children = getNodeChildren(element);\n        for (let i = children.length - 1; i >= 0; i--) {\n            const childElement = children[i];\n            const newTransform = getCombinedTransform(context, childElement, transform);\n            stack.push({ element: childElement, transform: newTransform, viewBox });\n        }\n    }\n}\nexport function drawRoot(context, element, svgTransform) {\n    let width = parseFloat(element.getAttribute('width'));\n    let height = parseFloat(element.getAttribute('height'));\n    if (isNaN(width) || isNaN(height)) {\n        // use only if both are set\n        width = height = undefined;\n    }\n    processRoot(context, element, svgTransform, width, height);\n}\n/**\n * The main switch to delegate drawing of `SVGElement`s\n * to different subroutines.\n */\nfunction drawElement(context, element, svgTransform) {\n    if (isHidden(element)) {\n        // just skip hidden elements\n        return;\n    }\n    // possibly apply a clip on the canvas before drawing on it\n    const clipPath = element.getAttribute('clip-path');\n    if (clipPath) {\n        applyClipPath(context, element, clipPath, svgTransform);\n    }\n    switch (element.tagName) {\n        case 'svg':\n        case 'symbol':\n            drawRoot(context, element, svgTransform);\n            break;\n        case 'rect':\n            drawRect(context, element, svgTransform);\n            break;\n        case 'path':\n            drawPath(context, element, svgTransform);\n            break;\n        case 'use':\n            drawUse(context, element, svgTransform);\n            break;\n        case 'line':\n            drawLine(context, element, svgTransform);\n            break;\n        case 'circle':\n            drawCircle(context, element, svgTransform);\n            break;\n        case 'ellipse':\n            drawEllipse(context, element, svgTransform);\n            break;\n        case 'polyline':\n            drawPolyline(context, element, svgTransform);\n            break;\n        case 'polygon':\n            drawPolygon(context, element, svgTransform);\n            break;\n        case 'text':\n            drawText(context, element, svgTransform);\n            break;\n        case 'image':\n            drawImage(context, element, svgTransform);\n            break;\n        case 'foreignObject':\n            drawForeignObject(context, element, svgTransform);\n            break;\n    }\n}\n","import { getCombinedTransform } from '../transformation';\nexport function drawUse(context, use, svgTransform) {\n    let href = use.href.baseVal;\n    if (href.startsWith('#')) {\n        href = href.substring(1);\n    }\n    const defElement = context.idElements[href];\n    if (defElement) {\n        let useWidth, useHeight;\n        if (use.getAttribute('width') && use.getAttribute('height')) {\n            // Use elements can overwrite the width which is important if it is a nested SVG\n            useWidth = use.width.baseVal.value;\n            useHeight = use.height.baseVal.value;\n        }\n        // We need to account for x and y attributes as well. Those change where the element is drawn.\n        // We can simply change the transform to include that.\n        const x = use.x.baseVal.value;\n        const y = use.y.baseVal.value;\n        let matrix = context.sourceSvg.createSVGMatrix().translate(x, y);\n        matrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;\n        // the defsElement itself might have a transform that needs to be incorporated\n        const elementTransform = context.sourceSvg.createSVGTransformFromMatrix(matrix);\n        // use elements must be processed in their context, particularly regarding\n        // the styling of them\n        if (!context.useElementContext) {\n            context.useElementContext = { root: use, referenced: defElement, parentContext: null };\n        }\n        else {\n            const newContext = {\n                root: use,\n                referenced: defElement,\n                parentContext: Object.assign({}, context.useElementContext)\n            };\n            context.useElementContext = newContext;\n        }\n        // draw the referenced element\n        context.processElement(context, defElement, getCombinedTransform(context, defElement, elementTransform), useWidth, useHeight);\n        // restore default context\n        if (context.useElementContext.parentContext) {\n            context.useElementContext = context.useElementContext.parentContext;\n        }\n        else {\n            context.useElementContext = null;\n        }\n    }\n}\n","import { appendPatternPaint } from '../styles/pattern';\nimport { parseStyleConfig } from '../styles/styles';\nimport { applyMatrix } from '../transformation';\nimport { appendSketchElement } from '../utils';\nimport { drawMarkers } from './marker';\nexport function drawLine(context, line, svgTransform) {\n    const p1 = { x: line.x1.baseVal.value, y: line.y1.baseVal.value };\n    const p2 = { x: line.x2.baseVal.value, y: line.y2.baseVal.value };\n    const { x: tp1x, y: tp1y } = applyMatrix(p1, svgTransform);\n    const { x: tp2x, y: tp2y } = applyMatrix(p2, svgTransform);\n    if (tp1x === tp2x && tp1y === tp2y) {\n        // zero-length line is not rendered\n        return;\n    }\n    const lineSketch = context.rc.line(tp1x, tp1y, tp2x, tp2y, parseStyleConfig(context, line, svgTransform));\n    appendPatternPaint(context, line, () => {\n        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n        proxy.x1.baseVal.value = tp1x;\n        proxy.y1.baseVal.value = tp1y;\n        proxy.x2.baseVal.value = tp2x;\n        proxy.y2.baseVal.value = tp2y;\n        return proxy;\n    });\n    appendSketchElement(context, line, lineSketch);\n    drawMarkers(context, line, [p1, p2], svgTransform);\n}\n","import { appendPatternPaint } from '../styles/pattern';\nimport { parseStyleConfig } from '../styles/styles';\nimport { applyMatrix } from '../transformation';\nimport { appendSketchElement, getPointsArray } from '../utils';\nimport { drawMarkers } from './marker';\nexport function drawPolyline(context, polyline, svgTransform) {\n    const points = getPointsArray(polyline);\n    const transformed = points.map(p => {\n        const pt = applyMatrix(p, svgTransform);\n        return [pt.x, pt.y];\n    });\n    const style = parseStyleConfig(context, polyline, svgTransform);\n    appendPatternPaint(context, polyline, () => {\n        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');\n        proxy.setAttribute('points', transformed.join(' '));\n        return proxy;\n    });\n    if (style.fill && style.fill !== 'none') {\n        const fillStyle = Object.assign(Object.assign({}, style), { stroke: 'none' });\n        appendSketchElement(context, polyline, context.rc.polygon(transformed, fillStyle));\n    }\n    appendSketchElement(context, polyline, context.rc.linearPath(transformed, style));\n    drawMarkers(context, polyline, points, svgTransform);\n}\n","import { applyTransform } from '../transformation';\nimport { appendSketchElement } from '../utils';\nexport function drawImage(context, svgImage, svgTransform) {\n    const href = svgImage.href.baseVal;\n    const x = svgImage.x.baseVal.value;\n    const y = svgImage.y.baseVal.value;\n    let width, height;\n    if (svgImage.getAttribute('width') && svgImage.getAttribute('height')) {\n        width = svgImage.width.baseVal.value;\n        height = svgImage.height.baseVal.value;\n    }\n    if (href.startsWith('data:') && href.indexOf('image/svg+xml') !== -1) {\n        // data:[<media type>][;charset=<character set>][;base64],<data>\n        const dataUrlRegex = /^data:([^,]*),(.*)/;\n        const match = dataUrlRegex.exec(href);\n        if (match && match.length > 2) {\n            const meta = match[1];\n            let svgString = match[2];\n            const isBase64 = meta.indexOf('base64') !== -1;\n            const isUtf8 = meta.indexOf('utf8') !== -1;\n            if (isBase64) {\n                svgString = atob(svgString);\n            }\n            if (!isUtf8) {\n                svgString = decodeURIComponent(svgString);\n            }\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(svgString, 'image/svg+xml');\n            const svg = doc.firstChild;\n            let matrix = context.sourceSvg.createSVGMatrix().translate(x, y);\n            matrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;\n            context.processElement(context, svg, context.sourceSvg.createSVGTransformFromMatrix(matrix), width, height);\n            return;\n        }\n    }\n    else {\n        const imageClone = svgImage.cloneNode();\n        const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        applyTransform(context, svgTransform, container);\n        container.appendChild(imageClone);\n        appendSketchElement(context, svgImage, container);\n    }\n}\n","import { applyTransform } from '../transformation';\nimport { appendSketchElement } from '../utils';\nexport function drawForeignObject(context, foreignObject, svgTransform) {\n    const foreignObjectClone = foreignObject.cloneNode(true);\n    const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    // foreignObject often relies on CSS styling, and just copying the <style> element\n    // won't do the trick, because sketching the SVG rebuilds the entire element tree, thus\n    // existing CSS rules don't apply anymore in most cases.\n    //\n    // To to make the MOST SIMPLE cases of foreignObject text elements work better,\n    // try to apply the computed style on the new SVG container.\n    // To properly fix it, we'd need to inline all computed styles recursively on the\n    // foreignObject tree.\n    const copyStyleProperties = [\n        'color',\n        'font-family',\n        'font-size',\n        'font-style',\n        'font-variant',\n        'font-weight'\n    ];\n    const style = getComputedStyle(foreignObject);\n    for (const prop of copyStyleProperties) {\n        container.style.setProperty(prop, style.getPropertyValue(prop));\n    }\n    // transform is already considered in svgTransform\n    foreignObjectClone.transform.baseVal.clear();\n    // transform the foreignObject to its destination location\n    applyTransform(context, svgTransform, container);\n    container.appendChild(foreignObjectClone);\n    appendSketchElement(context, foreignObjectClone, container);\n}\n","import { Random } from 'roughjs/bin/math';\n/**\n * A simple random number generator that allows for seeding.\n */\nexport class RandomNumberGenerator {\n    constructor(seed) {\n        // since we already depend on Rough.js, we may just use its seedable RNG implementation\n        this.rng = seed ? new Random(seed) : null;\n    }\n    /**\n     * Returns a random number in the given range.\n     */\n    next(range) {\n        var _a, _b;\n        const rnd = (_b = (_a = this.rng) === null || _a === void 0 ? void 0 : _a.next()) !== null && _b !== void 0 ? _b : Math.random();\n        if (range) {\n            const min = range[0];\n            const max = range[1];\n            return rnd * (max - min) + min;\n        }\n        return rnd;\n    }\n}\n","import rough from 'roughjs/bin/rough';\nimport { OutputType } from './OutputType';\nimport { processRoot } from './processor';\nimport { createPencilFilter } from './styles/textures';\nimport { getDefsElement } from './utils';\nimport { RandomNumberGenerator } from './RandomNumberGenerator';\n/**\n * Svg2Roughjs parses an SVG and converts it to a hand-drawn sketch.\n */\nexport class Svg2Roughjs {\n    /**\n     * Set the SVG that should be sketched.\n     */\n    set svg(svg) {\n        if (this.$svg !== svg) {\n            this.$svg = svg;\n            this.sourceSvgChanged();\n        }\n    }\n    /**\n     * Returns the SVG that should be sketched.\n     */\n    get svg() {\n        return this.$svg;\n    }\n    /**\n     * Sets the output format of the sketch.\n     *\n     * Applies only to instances that have been created with a\n     * container as output element instead of an actual SVG or canvas\n     * element.\n     *\n     * Throws when the given mode does not match the output element\n     * with which this instance was created.\n     */\n    set outputType(type) {\n        if (this.$outputType === type) {\n            return;\n        }\n        const incompatible = (type === OutputType.CANVAS && this.outputElement instanceof SVGSVGElement) ||\n            (type === OutputType.SVG && this.outputElement instanceof HTMLCanvasElement);\n        if (incompatible) {\n            throw new Error(`Output format ${type} incompatible with given output element ${this.outputElement.tagName}`);\n        }\n        this.$outputType = type;\n    }\n    /**\n     * Returns the currently configured output type.\n     */\n    get outputType() {\n        return this.$outputType;\n    }\n    /**\n     * Sets the config object that is passed to Rough.js and considered\n     * during rendering of the `SVGElement`s.\n     *\n     * Sets `fixedDecimalPlaceDigits` to `3` if not specified otherwise.\n     */\n    set roughConfig(config) {\n        if (typeof config.fixedDecimalPlaceDigits === 'undefined') {\n            config.fixedDecimalPlaceDigits = 3;\n        }\n        this.$roughConfig = config;\n    }\n    /**\n     * Returns the currently configured rendering configuration.\n     */\n    get roughConfig() {\n        return this.$roughConfig;\n    }\n    /**\n     * Creates a new instance of Svg2roughjs.\n     * @param target Either a container `HTMLDivElement` (or a selector for the container) to which a sketch should be added\n     * or an `HTMLCanvasElement` or `SVGSVGElement` that should be used as output target.\n     * @param outputType Whether the output should be an SVG or drawn to an HTML canvas.\n     * Defaults to SVG or CANVAS depending if the given target is of type `HTMLCanvasElement` or `SVGSVGElement`,\n     * otherwise it defaults to SVG.\n     * @param roughConfig Config object that is passed to Rough.js and considered during\n     * rendering of the `SVGElement`s.\n     */\n    constructor(target, outputType = OutputType.SVG, roughConfig = {}) {\n        /**\n         * Optional solid background color with which the canvas should be initialized.\n         * It is drawn on a transparent canvas by default.\n         */\n        this.backgroundColor = null;\n        /**\n         * Set a font-family for the rendering of text elements.\n         * If set to `null`, then the font-family of the SVGTextElement is used.\n         * By default, 'Comic Sans MS, cursive' is used.\n         */\n        this.fontFamily = 'Comic Sans MS, cursive';\n        /**\n         * Whether to randomize Rough.js' fillWeight, hachureAngle and hachureGap.\n         * Also randomizes the disableMultiStroke option of Rough.js.\n         * The randomness may be seeded with the `seed` property.\n         * By default `true`.\n         */\n        this.randomize = true;\n        /**\n         * Optional seed for the randomness when creating the sketch.\n         * Providing a value implicitly seeds Rough.js which may be overwritten\n         * by provding a different seed with the optional `roughConfig` property.\n         * By default `null`.\n         */\n        this.seed = null;\n        /**\n         * Whether pattern elements should be sketched or just copied to the output.\n         * For smaller pattern base sizes, it's often beneficial to just copy it over\n         * as the sketch will be too smalle to actually look sketched at all.\n         */\n        this.sketchPatterns = true;\n        /**\n         * Whether to apply a pencil filter.\n         */\n        this.pencilFilter = false;\n        this.width = 0;\n        this.height = 0;\n        this.$roughConfig = {};\n        this.idElements = {};\n        this.lastResult = null;\n        if (!target) {\n            throw new Error('No target provided');\n        }\n        const targetElement = typeof target === 'string' ? document.querySelector(target) : target;\n        if (!targetElement) {\n            throw new Error('Could not find target in document');\n        }\n        this.roughConfig = roughConfig;\n        this.outputElement = targetElement;\n        if (targetElement instanceof HTMLCanvasElement) {\n            this.$outputType = OutputType.CANVAS;\n        }\n        else if (targetElement instanceof SVGSVGElement) {\n            this.$outputType = OutputType.SVG;\n        }\n        else {\n            this.$outputType = outputType;\n        }\n    }\n    /**\n     * Triggers an entire redraw of the SVG which\n     * processes the input element anew.\n     * @param sourceSvgChanged When `true`, the given {@link svg} is re-evaluated as if it was set anew.\n     *  This allows the Svg2Rough.js instance to be used mutliple times with the same source SVG container but different contents.\n     * @returns A promise that resolves with the sketched output element or null if no {@link svg} is set.\n     */\n    sketch(sourceSvgChanged = false) {\n        var _a, _b;\n        if (!this.svg) {\n            return Promise.resolve(null);\n        }\n        if (sourceSvgChanged) {\n            this.sourceSvgChanged();\n        }\n        const sketchContainer = this.prepareRenderContainer();\n        const renderContext = this.createRenderContext(sketchContainer);\n        // prepare filter effects\n        if (this.pencilFilter) {\n            const defs = getDefsElement(renderContext);\n            defs.appendChild(createPencilFilter());\n        }\n        // sketchify the SVG\n        renderContext.processElement(renderContext, this.svg, null, this.width, this.height);\n        if (this.outputElement instanceof SVGSVGElement) {\n            // sketch already in the outputElement\n            return Promise.resolve(this.outputElement);\n        }\n        else if (this.outputElement instanceof HTMLCanvasElement) {\n            return this.drawToCanvas(renderContext, this.outputElement);\n        }\n        // remove the previous attached result\n        (_b = (_a = this.lastResult) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(this.lastResult);\n        // assume that the given output element is a container, thus append the sketch to it\n        if (this.outputType === OutputType.SVG) {\n            const svgSketch = renderContext.svgSketch;\n            this.outputElement.appendChild(svgSketch);\n            this.lastResult = svgSketch;\n            return Promise.resolve(svgSketch);\n        }\n        else {\n            // canvas output type\n            const canvas = document.createElement('canvas');\n            this.outputElement.appendChild(canvas);\n            this.lastResult = canvas;\n            return this.drawToCanvas(renderContext, canvas);\n        }\n    }\n    /**\n     * Creates a new context which contains the current state of the\n     * Svg2Roughs instance for rendering.\n     */\n    createRenderContext(sketchContainer) {\n        if (!this.svg) {\n            throw new Error('No source SVG set yet.');\n        }\n        let roughConfig = this.roughConfig;\n        if (this.seed !== null) {\n            roughConfig = Object.assign({ seed: this.seed }, roughConfig);\n        }\n        return {\n            rc: rough.svg(sketchContainer, { options: roughConfig }),\n            roughConfig: this.roughConfig,\n            fontFamily: this.fontFamily,\n            pencilFilter: this.pencilFilter,\n            randomize: this.randomize,\n            rng: new RandomNumberGenerator(this.seed),\n            sketchPatterns: this.sketchPatterns,\n            idElements: this.idElements,\n            sourceSvg: this.svg,\n            svgSketch: sketchContainer,\n            svgSketchIsInDOM: document.body.contains(sketchContainer),\n            styleSheets: Array.from(this.svg.querySelectorAll('style'))\n                .map(s => s.sheet)\n                .filter(s => s !== null),\n            processElement: processRoot\n        };\n    }\n    /**\n     * Helper method to draw the sketched SVG to a HTMLCanvasElement.\n     */\n    drawToCanvas(renderContext, canvas) {\n        canvas.width = this.width;\n        canvas.height = this.height;\n        const canvasCtx = canvas.getContext('2d');\n        canvasCtx.clearRect(0, 0, this.width, this.height);\n        return new Promise(resolve => {\n            const svgString = new XMLSerializer().serializeToString(renderContext.svgSketch);\n            const img = new Image();\n            img.onload = function () {\n                canvasCtx.drawImage(this, 0, 0);\n                resolve(canvas);\n            };\n            img.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgString)}`;\n        });\n    }\n    /**\n     * Prepares the given SVG element depending on the set properties.\n     */\n    prepareRenderContainer() {\n        let svgElement;\n        if (this.outputElement instanceof SVGSVGElement) {\n            // just use the user given outputElement directly as sketch-container\n            svgElement = this.outputElement;\n        }\n        else {\n            // we need a separate svgElement as output element\n            svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        }\n        // make sure it has all the proper namespaces\n        svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n        svgElement.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');\n        // clear SVG element\n        while (svgElement.firstChild) {\n            svgElement.removeChild(svgElement.firstChild);\n        }\n        // set size\n        svgElement.setAttribute('width', this.width.toString());\n        svgElement.setAttribute('height', this.height.toString());\n        // apply backgroundColor\n        let backgroundElement;\n        if (this.backgroundColor) {\n            backgroundElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n            backgroundElement.width.baseVal.value = this.width;\n            backgroundElement.height.baseVal.value = this.height;\n            backgroundElement.setAttribute('fill', this.backgroundColor);\n            svgElement.appendChild(backgroundElement);\n        }\n        // use round linecap to emphasize a ballpoint pen like drawing\n        svgElement.setAttribute('stroke-linecap', 'round');\n        return svgElement;\n    }\n    /**\n     * Initializes the size based on the currently set SVG and collects elements\n     * with an ID property that may be referenced in the SVG.\n     */\n    sourceSvgChanged() {\n        const svg = this.$svg;\n        if (svg) {\n            const precision = this.roughConfig.fixedDecimalPlaceDigits;\n            this.width = parseFloat(this.coerceSize(svg, 'width', 300).toFixed(precision));\n            this.height = parseFloat(this.coerceSize(svg, 'height', 150).toFixed(precision));\n            // pre-process defs for subsequent references\n            this.collectElementsWithID();\n        }\n    }\n    /**\n     * Stores elements with IDs for later use.\n     */\n    collectElementsWithID() {\n        this.idElements = {};\n        const elementsWithID = Array.prototype.slice.apply(this.svg.querySelectorAll('*[id]'));\n        for (const elt of elementsWithID) {\n            const id = elt.getAttribute('id');\n            if (id) {\n                this.idElements[id] = elt;\n            }\n        }\n    }\n    /**\n     * Helper to handle percentage values for width / height of the input SVG.\n     */\n    coerceSize(svg, property, fallback) {\n        let size = fallback;\n        const hasViewbox = svg.hasAttribute('viewBox');\n        if (svg.hasAttribute(property)) {\n            // percentage sizes for the root SVG are unclear, thus use viewBox if available\n            if (svg[property].baseVal.unitType === SVGLength.SVG_LENGTHTYPE_PERCENTAGE && hasViewbox) {\n                size = svg.viewBox.baseVal[property];\n            }\n            else {\n                size = svg[property].baseVal.value;\n            }\n        }\n        else if (hasViewbox) {\n            size = svg.viewBox.baseVal[property];\n        }\n        return size;\n    }\n}\n","export function createPencilFilter() {\n    const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');\n    filter.setAttribute('id', 'pencilTextureFilter');\n    filter.setAttribute('x', '0%');\n    filter.setAttribute('y', '0%');\n    filter.setAttribute('width', '100%');\n    filter.setAttribute('height', '100%');\n    filter.setAttribute('filterUnits', 'objectBoundingBox');\n    const feTurbulence = document.createElementNS('http://www.w3.org/2000/svg', 'feTurbulence');\n    feTurbulence.setAttribute('type', 'fractalNoise');\n    feTurbulence.setAttribute('baseFrequency', '2');\n    feTurbulence.setAttribute('numOctaves', '5');\n    feTurbulence.setAttribute('stitchTiles', 'stitch');\n    feTurbulence.setAttribute('result', 'f1');\n    filter.appendChild(feTurbulence);\n    const feColorMatrix = document.createElementNS('http://www.w3.org/2000/svg', 'feColorMatrix');\n    feColorMatrix.setAttribute('type', 'matrix');\n    feColorMatrix.setAttribute('values', '0 0 0 0 0, 0 0 0 0 0, 0 0 0 0 0, 0 0 0 -1.5 1.5');\n    feColorMatrix.setAttribute('result', 'f2');\n    filter.appendChild(feColorMatrix);\n    const feComposite = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');\n    feComposite.setAttribute('operator', 'in');\n    feComposite.setAttribute('in', 'SourceGraphic');\n    feComposite.setAttribute('in2', 'f2');\n    feComposite.setAttribute('result', 'f3');\n    filter.appendChild(feComposite);\n    return filter;\n}\n"],"names":["OutputType","getNodeChildren","element","children","node","i","nodes","childNodes","nodeType","push","getParentElement","parentNode","Node","ELEMENT_NODE","reparentNodes","newParent","source","firstChild","append","getIdFromUrl","url","result","exec","length","SKETCH_CLIP_ATTRIBUTE","PATH_CURVES_REGEX","getDefsElement","context","svgSketchDefs","parent","svgSketch","defs","document","createElementNS","childElementCount","insertBefore","firstElementChild","appendChild","getPointsArray","pointsAttr","getAttribute","coordinateRegexp","indexOf","pointList","split","points","currentEntry","coordinates","x","parseFloat","y","next","appendSketchElement","sketchElement","sketch","sketchClipPathId","applyPencilFilter","pencilFilter","tagName","attributes","g","setAttribute","removeAttribute","sketchPath","path","options","test","Object","assign","preserveVertices","rc","getEffectiveAttribute","attributeName","currentUseCtx","attr","getComputedStyle","useCtx","nextCtx","referenced","root","parentContext","sourceSvg","getEffectiveElementOpacity","currentOpacity","elementOpacity","Math","min","max","substring","nextUseCtx","appendPatternPaint","sourceElement","patternProxyCreator","fillId","strokeId","getPatternId","id","idElements","SVGPatternElement","getPatternPaintIds","patternProxy","strokeWidth","useElementContext","appendPatternDefsElement","patternId","sketchDefs","defId","querySelector","sourceDefElement","sketchPatterns","cloneNode","sketchPattern","roughOverwrites","proxySource","proxyContext","roughConfig","processElement","sketchFragment","fillStyle","roughness","defElementRoot","DIMENSION_REGEX","ABSOLUTE_UNITS","in","cm","mm","pt","pc","DPI","px","SQRT2","sqrt","convertToPixelUnit","dimensionValue","attribute","value","unit","parseDimension","isAbsoluteUnit","_a","conversion","absToPixel","coordinateSystemSize","viewBox","w","h","percentage","width","height","fraction","percentageToPixel","_b","refWidth","window","innerWidth","refHeight","innerHeight","Error","viewportLengthToPixel","rootElement","documentElement","fontSizeDimension","fontSize","zeroCharWidth","measureContainer","style","visibility","createTextNode","bbox","getBBox","removeChild","measureZeroCharacter","effectiveFontSize","fontSizePx","fontRelativeToPixel","relToPixel","dimension","match","toLowerCase","isIdentityTransform","svgTransform","matrix","a","b","c","d","e","f","isTranslationTransform","applyMatrix","point","getSvgTransform","transform","baseVal","numberOfItems","consolidate","getCombinedTransform","elementTransform","elementTransformMatrix","combinedMatrix","multiply","createSVGTransformFromMatrix","applyTransform","getItem","setMatrix","appendItem","getStopColor","stop","stopColorStr","tinycolor","averageColor","colorArray","count","r","forEach","color","toRgb","getStopOffset","offset","createPen","angle","gap","weight","getBoundingClientRect","aspectRatio","sideLength","legacyConfig","normal","horizontal","vertical","small","defaultConfig","getPenConfiguration","getHachureAngle","getHachureGap","getFillWeight","rng","isFinite","parseStyleConfig","precision","fixedDecimalPlaceDigits","config","scaleFactor","m","det","abs","fill","fillOpacity","getOpacity","gradientColor","convertGradient","setAlpha","toString","stroke","strokeOpacity","scaledWidth","toFixed","strokeDashArray","strokeLineDash","filter","entry","map","dash","scaledLineDash","strokeDashOffset","scaledOffset","strokeLineDashOffset","randomize","hachureAngle","hachureGap","round","fillWeight","disableMultiStroke","opacity","paint","SVGLinearGradientElement","SVGRadialGradientElement","gradient","stops","Array","prototype","slice","apply","querySelectorAll","resolution","discreteColors","lastColor","currentColor","currentOffset","combinedColor","entries","mixedColor","gradientToColor","str","p","drawMarkers","startPt","endPt","markerStartId","markerStartElement","orientAngle","nextPt","orientAttr","reverse","prevPt","isClosedPath","getBisectingAngle","getAngle","createSVGMatrix","translate","rotate","scale","getScaleFactor","markerTransform","markerEndId","markerEndElement","markerMidId","markerMidElement","loc","marker","referrer","markerUnits","p0","p1","crossingPt","vIn","vectorAngle","refPoint","refAngle","sign","v1","v2","a1","atan2","K","PI","applyPatternPaint","rect","proxy","applyClipPath","owner","clipPathAttr","clipPath","targetDefs","clipContainer","stack","pop","storeSketchClipId","childElement","childTransform","applyElementClip","console","error","container","rx","hasAttribute","ry","clip","applyRectClip","circle","cx","cy","applyCircleClip","ellipse","applyEllipseClip","polygon","applyPolygonClip","applyPathClip","drawText","text","textClone","clear","cssFont","asStyleString","effectiveAttributes","fontStyle","fontWeight","fontFamily","fontFamiliy","trim","getCssFont","args","ret","s","concatStyleStrings","copyTextStyleAttributes","origChildren","child","SVGTSpanElement","useCustomFontFamily","hasClipPath","original","clone","fitFontSizeCore","fitFontSize","originalSize","cloneWidth","svgSketchIsInDOM","hiddenElementStyle","origStyle","body","previousParent","parentElement","measureText","newFontSize","srcElement","tgtElement","dominantBaseline","textAnchor","processRoot","currentViewBox","SVGSVGElement","SVGSymbolElement","SVGMarkerElement","rootX","rootY","mw","mh","rootTransform","viewBoxX","viewBoxY","viewBoxWidth","viewBoxHeight","sx","sy","centerviewportX","centerviewportY","centerViewBoxX","centerViewBoxY","scaleNonUniform","refX","refY","drawElement","newTransform","display","isHidden","isNaN","undefined","drawRoot","p2","transformedWidth","transformedHeight","transformedBounds","factor","p3c1","p3c2","p3","p5c1","p5c2","p5","p7c1","p7c2","p7","p9c1","p9c2","p4","sketchRect","rectangle","drawRect","dataAttrs","pathData","SVGPathData","toAbs","SVGPathDataTransformer","NORMALIZE_HVZ","NORMALIZE_ST","transformedPathData","commands","cmd","MATRIX","encodedPathData","encodeSVGPath","pathSketch","currentSubPathBegin","type","MOVE_TO","LINE_TO","QUAD_TO","SMOOTH_QUAD_TO","CURVE_TO","SMOOTH_CURVE_TO","ARC","HORIZ_LINE_TO","VERT_LINE_TO","CLOSE_PATH","drawPath","use","href","startsWith","defElement","useWidth","useHeight","newContext","drawUse","line","x1","y1","x2","y2","tp1x","tp1y","tp2x","tp2y","lineSketch","drawLine","center","transformedRadius","c1","c2","c4","c6","c8","drawCircle","radiusPoint","transformedRx","transformedRy","drawEllipse","polyline","transformed","join","linearPath","drawPolyline","polygonSketch","drawPolygon","svgImage","meta","svgString","isBase64","isUtf8","atob","decodeURIComponent","svg","DOMParser","parseFromString","imageClone","drawImage","foreignObject","foreignObjectClone","copyStyleProperties","prop","setProperty","getPropertyValue","drawForeignObject","RandomNumberGenerator","constructor","seed","this","Random","range","rnd","random","Svg2Roughjs","$svg","sourceSvgChanged","outputType","$outputType","CANVAS","outputElement","SVG","HTMLCanvasElement","$roughConfig","target","backgroundColor","lastResult","targetElement","Promise","resolve","sketchContainer","prepareRenderContainer","renderContext","createRenderContext","feTurbulence","feColorMatrix","feComposite","createPencilFilter","drawToCanvas","canvas","createElement","rough","contains","styleSheets","from","sheet","canvasCtx","getContext","clearRect","XMLSerializer","serializeToString","img","Image","onload","src","encodeURIComponent","svgElement","backgroundElement","setAttributeNS","coerceSize","collectElementsWithID","elementsWithID","elt","property","fallback","size","hasViewbox","unitType","SVGLength","SVG_LENGTHTYPE_PERCENTAGE"],"mappings":"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"}