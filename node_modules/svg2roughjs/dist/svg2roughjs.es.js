import rough from 'roughjs/bin/rough';
import tinycolor from 'tinycolor2';
import { SVGPathData, SVGPathDataTransformer, encodeSVGPath } from 'svg-pathdata';
import { Random } from 'roughjs/bin/math';

var OutputType;
(function (OutputType) {
    OutputType[OutputType["SVG"] = 0] = "SVG";
    OutputType[OutputType["CANVAS"] = 1] = "CANVAS";
})(OutputType || (OutputType = {}));

/**
 * Returns the Node's children, since Node.prototype.children is not available on all browsers.
 * https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/children
 */
function getNodeChildren(element) {
    if (typeof element.children !== 'undefined') {
        return element.children;
    }
    let i = 0;
    let node;
    const nodes = element.childNodes;
    const children = [];
    while ((node = nodes[i++])) {
        if (node.nodeType === 1) {
            children.push(node);
        }
    }
    return children;
}
/**
 * IE doesn't support `element.parentElement` in SVG documents.
 * This helper utilizes `parentNode` and checks for the `nodeType`.
 */
function getParentElement(node) {
    const parentNode = node.parentNode;
    if (parentNode && parentNode.nodeType === Node.ELEMENT_NODE) {
        return parentNode;
    }
    return null;
}
/**
 * Moves the child-nodes from the source to a new parent.
 */
function reparentNodes(newParent, source) {
    while (source.firstChild) {
        newParent.append(source.firstChild);
    }
    return newParent;
}
/**
 * Returns the id from the url string
 */
function getIdFromUrl(url) {
    if (url === null) {
        return null;
    }
    const result = /url\('#?(.*?)'\)/.exec(url) || /url\("#?(.*?)"\)/.exec(url) || /url\(#?(.*?)\)/.exec(url);
    if (result && result.length > 1) {
        return result[1];
    }
    return null;
}

/**
 * Attribute for storing the new clip-path IDs for the sketch output.
 */
const SKETCH_CLIP_ATTRIBUTE = 'data-sketchy-clip-path';
/**
 * Regexp that detects curved commands in path data.
 */
const PATH_CURVES_REGEX = /[acsqt]/i;
/**
 * Returns the <defs> element of the output SVG sketch.
 */
function getDefsElement(context) {
    if (context.svgSketchDefs) {
        return context.svgSketchDefs;
    }
    const parent = context.svgSketch;
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    if (parent.childElementCount > 0) {
        parent.insertBefore(defs, parent.firstElementChild);
    }
    else {
        parent.appendChild(defs);
    }
    context.svgSketchDefs = defs;
    return defs;
}
function getPointsArray(element) {
    const pointsAttr = element.getAttribute('points');
    if (!pointsAttr) {
        return [];
    }
    let coordinateRegexp;
    if (pointsAttr.indexOf(' ') > 0) {
        // just assume that the coordinates (or pairs) are separated with space
        coordinateRegexp = /\s+/g;
    }
    else {
        // there are no spaces, so assume comma separators
        coordinateRegexp = /,/g;
    }
    const pointList = pointsAttr.split(coordinateRegexp);
    const points = [];
    for (let i = 0; i < pointList.length; i++) {
        const currentEntry = pointList[i];
        const coordinates = currentEntry.split(',');
        if (coordinates.length === 2) {
            points.push({ x: parseFloat(coordinates[0]), y: parseFloat(coordinates[1]) });
        }
        else {
            // space as separators, take next entry as y coordinate
            const next = i + 1;
            if (next < pointList.length) {
                points.push({ x: parseFloat(currentEntry), y: parseFloat(pointList[next]) });
                // skip the next entry
                i = next;
            }
        }
    }
    return points;
}
/**
 * Helper method to append the returned `SVGGElement` from Rough.js which
 * also post processes the result e.g. by applying the clip.
 */
function appendSketchElement(context, element, sketchElement) {
    let sketch = sketchElement;
    // original element may have a clip-path
    const sketchClipPathId = element.getAttribute(SKETCH_CLIP_ATTRIBUTE);
    const applyPencilFilter = context.pencilFilter && element.tagName !== 'text';
    // wrap it in another container to safely apply post-processing attributes,
    // though avoid no-op <g> containers
    const isPlainContainer = sketch.tagName === 'g' && sketch.attributes.length === 0;
    if (!isPlainContainer && (sketchClipPathId || applyPencilFilter)) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.appendChild(sketch);
        sketch = g;
    }
    if (sketchClipPathId) {
        sketch.setAttribute('clip-path', `url(#${sketchClipPathId})`);
        element.removeAttribute(SKETCH_CLIP_ATTRIBUTE);
    }
    if (applyPencilFilter) {
        sketch.setAttribute('filter', 'url(#pencilTextureFilter)');
    }
    context.svgSketch.appendChild(sketch);
}
/**
 * Helper method to sketch a path.
 * Paths with curves should utilize the preserverVertices option to avoid line disjoints.
 * For non-curved paths it looks nicer to actually allow these diskoints.
 * @returns Returns the sketched SVGElement
 */
function sketchPath(context, path, options) {
    if (PATH_CURVES_REGEX.test(path)) {
        options = options ? Object.assign(Object.assign({}, options), { preserveVertices: true }) : { preserveVertices: true };
    }
    return context.rc.path(path, options);
}
/**
 * Helper funtion to sketch a DOM fragment.
 * Wraps the given element in an SVG and runs the processor on it to sketch the fragment.
 * The result is then unpacked and returned.
 */
function sketchFragment(context, g, roughOverwrites) {
    const proxySource = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    proxySource.appendChild(g);
    const proxyContext = Object.assign(Object.assign({}, context), { sourceSvg: proxySource, svgSketch: document.createElementNS('http://www.w3.org/2000/svg', 'svg'), roughConfig: Object.assign(Object.assign({}, context.roughConfig), roughOverwrites) });
    proxyContext.processElement(proxyContext, g, null);
    return reparentNodes(document.createElementNS('http://www.w3.org/2000/svg', 'g'), proxyContext.svgSketch);
}
/**
 * Measures the text in the context of the sketchSvg to account for inherited text
 * attributes.
 * The given text element must be a child of the svgSketch.
 */
function measureText({ svgSketch, svgSketchIsInDOM }, text) {
    const hiddenElementStyle = 'visibility:hidden;position:absolute;left:-100%;top-100%;';
    const origStyle = svgSketch.getAttribute('style');
    if (origStyle) {
        svgSketch.setAttribute('style', `${origStyle};${hiddenElementStyle}`);
    }
    else {
        svgSketch.setAttribute('style', hiddenElementStyle);
    }
    // the element must be in the DOM for getBBox
    const body = document.body;
    const previousParent = svgSketch.parentElement;
    if (!svgSketchIsInDOM) {
        body.appendChild(svgSketch);
    }
    const { width, height } = text.getBBox();
    // make sure to not change the DOM hierarchy of the element
    if (!svgSketchIsInDOM) {
        body.removeChild(svgSketch);
        if (previousParent) {
            previousParent.appendChild(svgSketch);
        }
    }
    if (origStyle) {
        svgSketch.setAttribute('style', origStyle);
    }
    else {
        svgSketch.removeAttribute('style');
    }
    return { w: width, h: height };
}

/**
 * Returns the attribute value of an element under consideration
 * of inherited attributes from the `parentElement`.
 * @param attributeName Name of the attribute to look up
 * @param currentUseCtx Consider different DOM hierarchy for use elements
 * @return attribute value if it exists
 */
function getEffectiveAttribute(context, element, attributeName, currentUseCtx) {
    // getComputedStyle doesn't work for, e.g. <svg fill='rgba(...)'>
    let attr;
    if (!currentUseCtx) {
        attr =
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            getComputedStyle(element)[attributeName] || element.getAttribute(attributeName);
    }
    else {
        // use elements traverse a different parent-hierarchy, thus we cannot use getComputedStyle here
        attr = element.getAttribute(attributeName);
    }
    if (!attr) {
        let parent = getParentElement(element);
        const useCtx = currentUseCtx;
        let nextCtx = useCtx;
        if (useCtx && useCtx.referenced === element) {
            // switch context and traverse the use-element parent now
            parent = useCtx.root;
            nextCtx = useCtx.parentContext;
        }
        if (!parent || parent === context.sourceSvg) {
            return;
        }
        return getEffectiveAttribute(context, parent, attributeName, nextCtx);
    }
    return attr;
}
/**
 * Traverses the given elements hierarchy bottom-up to determine its effective
 * opacity attribute.
 * @param currentUseCtx Consider different DOM hierarchy for use elements
 */
function getEffectiveElementOpacity(context, element, currentOpacity, currentUseCtx) {
    let attr;
    if (!currentUseCtx) {
        attr = getComputedStyle(element)['opacity'] || element.getAttribute('opacity');
    }
    else {
        // use elements traverse a different parent-hierarchy, thus we cannot use getComputedStyle here
        attr = element.getAttribute('opacity');
    }
    if (attr) {
        let elementOpacity = 1;
        if (attr.indexOf('%') !== -1) {
            elementOpacity = Math.min(1, Math.max(0, parseFloat(attr.substring(0, attr.length - 1)) / 100));
        }
        else {
            elementOpacity = Math.min(1, Math.max(0, parseFloat(attr)));
        }
        // combine opacities
        currentOpacity *= elementOpacity;
    }
    // traverse upwards to combine parent opacities as well
    let parent = getParentElement(element);
    const useCtx = currentUseCtx;
    let nextUseCtx = useCtx;
    if (useCtx && useCtx.referenced === element) {
        // switch context and traverse the use-element parent now
        parent = useCtx.root;
        nextUseCtx = useCtx.parentContext;
    }
    if (!parent || parent === context.sourceSvg) {
        return currentOpacity;
    }
    return getEffectiveElementOpacity(context, parent, currentOpacity, nextUseCtx);
}

/**
 * If the input element has a pattern stroke/fill, an additional element is added to the result,
 * which just provides the pattern storke/fill.
 * @param patternProxyCreator Should return the transformed `SVGElement` that holds the stroke/fill pattern.
 */
function appendPatternPaint(context, sourceElement, patternProxyCreator) {
    const { fillId, strokeId } = getPatternPaintIds(context, sourceElement);
    if (fillId !== null || strokeId !== null) {
        // the additional element that should provide the pattern
        const patternProxy = patternProxyCreator();
        patternProxy.setAttribute('fill', fillId !== null ? `url(#${fillId})` : 'none');
        patternProxy.setAttribute('stroke', strokeId !== null ? `url(#${strokeId})` : 'none');
        const strokeWidth = getEffectiveAttribute(context, sourceElement, 'stroke-width', context.useElementContext);
        patternProxy.setAttribute('stroke-width', strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : '0');
        // append the proxy
        appendSketchElement(context, sourceElement, patternProxy);
        // add the pattern defs
        appendPatternDefsElement(context, fillId);
        appendPatternDefsElement(context, strokeId);
    }
}
/**
 * Returns the element's referenced fill and stroke pattern ids if there are any.
 */
function getPatternPaintIds(context, element) {
    function getPatternId(attributeName) {
        const attr = element.getAttribute(attributeName);
        if (attr && attr.indexOf('url') !== -1) {
            const id = getIdFromUrl(attr);
            if (id) {
                const paint = context.idElements[id];
                if (paint instanceof SVGPatternElement) {
                    return id;
                }
            }
        }
        return null;
    }
    return { fillId: getPatternId('fill'), strokeId: getPatternId('stroke') };
}
/**
 * Obtains the pattern fill element from the source SVG and provides it as defs element
 * in the output sketch element if missing.
 */
function appendPatternDefsElement(context, patternId) {
    if (patternId === null) {
        return;
    }
    const sketchDefs = getDefsElement(context);
    const defId = `#${patternId}`;
    if (!sketchDefs.querySelector(defId)) {
        const sourceDefElement = context.sourceSvg.querySelector(defId);
        if (sourceDefElement) {
            if (!context.sketchPatterns) {
                // just copy the pattern to the output
                sketchDefs.appendChild(sourceDefElement.cloneNode(true));
                return;
            }
            // create a proxy for the pattern element to be sketched separately
            const patternElement = reparentNodes(document.createElementNS('http://www.w3.org/2000/svg', 'g'), sourceDefElement.cloneNode(true));
            // sketch the pattern separately from the main processor loop
            const sketchPattern = sketchFragment(context, patternElement, {
                // patterns usually don't benefit from too crazy sketch values due to their base-size
                fillStyle: 'solid',
                roughness: 0.5 // TODO ideally this should scale with the pattern's size
            });
            // move the result into an copy of the original def element
            const defElementRoot = sourceDefElement.cloneNode();
            sketchDefs.appendChild(reparentNodes(defElementRoot, sketchPattern));
        }
    }
}

/**
 * Dimension parsing regexp.
 *
 * https://www.w3.org/TR/css3-values/#numbers
 * "a number is either an integer, or zero or more decimal digits
 * followed by a dot (.) followed by one or more decimal digits and
 * optionally an exponent composed of "e" or "E" and an integer."
 *
 * Don't forget the signs though...
 * => ([+-]?(?:\d+|\d*\.\d+(?:[eE][+-]?\d+)?))
 *
 * To get the unit, itself, just allow any alphabetic sequence and the '%' char.
 * => ([a-z]*|%)
 */
const DIMENSION_REGEX = /^([+-]?(?:\d+|\d*\.\d+(?:[eE][+-]?\d+)?))([a-z]*|%)$/;
/**
 * Commonly used dpi for unit conversion.
 */
const DPI = 96;
/**
 * Conversion factors for absolute units.
 * https://developer.mozilla.org/en-US/docs/web/css/length
 */
const ABSOLUTE_UNITS = {
    in: DPI,
    cm: DPI / 2.54,
    mm: DPI / 25.4,
    pt: DPI / 72,
    pc: DPI / 6,
    px: 1
};
// pre-calculated factor for % conversion
const SQRT2 = Math.sqrt(2);
/**
 * Converts the given string to px unit. May be either a
 * [length](https://developer.mozilla.org/de/docs/Web/SVG/Content_type#Length)
 * or a [percentage](https://developer.mozilla.org/de/docs/Web/SVG/Content_type#Percentage).
 * @returns The value in px unit
 */
function convertToPixelUnit(context, element, dimensionValue, attribute) {
    const { value, unit } = parseDimension(dimensionValue);
    if (isAbsoluteUnit(unit)) {
        return absToPixel(value, unit);
    }
    return relToPixel(context, element, attribute, value, unit);
}
/**
 * Parses the given string and returns a dimension, which is a
 * [number](https://www.w3.org/TR/css3-values/#numbers) followed
 * by a unit identifier.
 */
function parseDimension(dimension) {
    const match = dimension.match(DIMENSION_REGEX);
    if (match === null || match.length !== 3) {
        throw new Error(`Cannot parse dimension: ${dimension}`);
    }
    return { value: parseFloat(match[1]), unit: match[2].toLowerCase() || 'px' };
}
/**
 * unit-css converts per HTML spec, which is differently for percentages in SVG
 * https://www.w3.org/TR/SVG/coords.html#Units
 * https://oreillymedia.github.io/Using_SVG/guide/units.html
 * @param percentage [0, 100]
 * @param viewBox The coordinate system to evaluate the percentage against
 */
function percentageToPixel(attribute, percentage, { w: width, h: height } = { w: 0, h: 0 }) {
    const fraction = percentage / 100;
    // x and y are relative to the coordinate system's width or height
    if (attribute === 'x') {
        return fraction * width;
    }
    if (attribute === 'y') {
        return fraction * height;
    }
    return fraction * (Math.sqrt(width * width + height * height) / SQRT2);
}
/**
 * Converts an absolute unit to pixels.
 */
function absToPixel(value, unit) {
    var _a;
    const conversion = (_a = ABSOLUTE_UNITS[unit]) !== null && _a !== void 0 ? _a : 1;
    return value * conversion;
}
/**
 * Converts a relative unit to pixels.
 */
function relToPixel(context, element, attribute, value, unit) {
    var _a;
    const coordinateSystemSize = (_a = context.viewBox) !== null && _a !== void 0 ? _a : { w: 0, h: 0 };
    if (unit === '%') {
        return percentageToPixel(attribute, value, coordinateSystemSize);
    }
    if (unit === 'vw' || unit === 'vh' || unit === 'vmin' || unit === 'vmax') {
        return viewportLengthToPixel(value, unit, coordinateSystemSize);
    }
    if (unit === 'em' || unit === 'ex' || unit === 'ch' || unit === 'rem') {
        return fontRelativeToPixel(context, element, value, unit);
    }
    throw new Error(`Unsupported relative length unit: ${unit}`);
}
/**
 * https://oreillymedia.github.io/Using_SVG/guide/units.html#units-viewport-reference
 */
function viewportLengthToPixel(value, unit, { w: width, h: height } = { w: 0, h: 0 }) {
    var _a, _b;
    const fraction = value / 100;
    const refWidth = (_a = window.innerWidth) !== null && _a !== void 0 ? _a : width;
    const refHeight = (_b = window.innerHeight) !== null && _b !== void 0 ? _b : height;
    if (unit === 'vw') {
        return fraction * refWidth;
    }
    if (unit === 'vh') {
        return fraction * refHeight;
    }
    if (unit === 'vmin') {
        return fraction * Math.min(refWidth, refHeight);
    }
    if (unit === 'vmax') {
        return fraction * Math.max(refWidth, refHeight);
    }
    throw new Error(`Not a viewport length unit: ${unit}`);
}
/**
 * https://oreillymedia.github.io/Using_SVG/guide/units.html#units-relative-reference
 */
function fontRelativeToPixel(context, element, value, unit) {
    var _a;
    if (unit === 'rem') {
        const rootElement = document.documentElement;
        const fontSizeDimension = parseDimension(getComputedStyle(rootElement).fontSize);
        const fontSizePx = fontSizeDimension.unit === 'px' ? fontSizeDimension.value : 16;
        return value * fontSizePx;
    }
    if (unit === 'ch') {
        const zeroCharWidth = measureZeroCharacter(element);
        return value * zeroCharWidth;
    }
    // this should return a px font-size due to the getComputedStyle, otherwise use 16px as default fallback
    const effectiveFontSize = (_a = getEffectiveAttribute(context, element, 'font-size', context.useElementContext)) !== null && _a !== void 0 ? _a : '16px';
    const fontSizeDimension = parseDimension(effectiveFontSize);
    const fontSizePx = fontSizeDimension.unit === 'px' ? fontSizeDimension.value : 16;
    if (unit === 'em') {
        return value * fontSizePx;
    }
    if (unit === 'ex') {
        return value * fontSizePx * 0.5;
    }
    throw new Error(`Not a font relative unit: ${unit}`);
}
/**
 * Whether the given unit is an absolute unit.
 */
function isAbsoluteUnit(unit) {
    return !!ABSOLUTE_UNITS[unit];
}
/**
 * Returns the width of the '0' character in the context of the element.
 */
function measureZeroCharacter(element) {
    const parent = getParentElement(element);
    if (!parent) {
        return 1;
    }
    const measureContainer = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    measureContainer.style.visibility = 'hidden';
    measureContainer.appendChild(document.createTextNode('0'));
    parent.appendChild(measureContainer);
    const bbox = measureContainer.getBBox();
    parent.removeChild(measureContainer);
    return bbox.width;
}

/**
 * Whether the given SVGTransform resembles an identity transform.
 * @returns Whether the transform is an identity transform.
 *  Returns true if transform is undefined.
 */
function isIdentityTransform(svgTransform) {
    if (!svgTransform) {
        return true;
    }
    const matrix = svgTransform.matrix;
    return (!matrix ||
        (matrix.a === 1 &&
            matrix.b === 0 &&
            matrix.c === 0 &&
            matrix.d === 1 &&
            matrix.e === 0 &&
            matrix.f === 0));
}
/**
 * Whether the given SVGTransform does not scale nor skew.
 * @returns Whether the given SVGTransform does not scale nor skew.
 *  Returns true if transform is undefined.
 */
function isTranslationTransform(svgTransform) {
    if (!svgTransform) {
        return true;
    }
    const matrix = svgTransform.matrix;
    return !matrix || (matrix.a === 1 && matrix.b === 0 && matrix.c === 0 && matrix.d === 1);
}
/**
 * Applies a given `SVGTransform` to the point.
 *
 * [a c e] [x] = (a*x + c*y + e)
 * [b d f] [y] = (b*x + d*y + f)
 * [0 0 1] [1] = (0 + 0 + 1)
 */
function applyMatrix(point, svgTransform) {
    if (!svgTransform) {
        return point;
    }
    const matrix = svgTransform.matrix;
    const x = matrix.a * point.x + matrix.c * point.y + matrix.e;
    const y = matrix.b * point.x + matrix.d * point.y + matrix.f;
    return { x, y };
}
/**
 * Returns the consolidated transform of the given element.
 */
function getSvgTransform(element) {
    if (element.transform && element.transform.baseVal.numberOfItems > 0) {
        return element.transform.baseVal.consolidate();
    }
    return null;
}
/**
 * Combines the given transform with the element's transform.
 * If no transform is given, it returns the SVGTransform of the element.
 */
function getCombinedTransform(context, element, transform) {
    if (!transform) {
        return getSvgTransform(element);
    }
    const elementTransform = getSvgTransform(element);
    if (elementTransform) {
        const elementTransformMatrix = elementTransform.matrix;
        const combinedMatrix = transform.matrix.multiply(elementTransformMatrix);
        return context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);
    }
    return transform;
}
/**
 * Applies the given svgTransform to the given element.
 * @param element The element to which the transform should be applied.
 */
function applyTransform(context, svgTransform, element) {
    if (svgTransform && svgTransform.matrix && !isIdentityTransform(svgTransform)) {
        const matrix = svgTransform.matrix;
        if (element.transform.baseVal.numberOfItems > 0) {
            element.transform.baseVal.getItem(0).setMatrix(matrix);
        }
        else {
            element.transform.baseVal.appendItem(svgTransform);
        }
    }
}

/**
 * Converts an SVG gradient to a color by mixing all stop colors
 * with `tinycolor.mix`.
 */
function gradientToColor(gradient, opacity) {
    const stops = Array.prototype.slice.apply(gradient.querySelectorAll('stop'));
    if (stops.length === 0) {
        return 'transparent';
    }
    else if (stops.length === 1) {
        const color = getStopColor(stops[0]);
        color.setAlpha(opacity);
        return color.toString();
    }
    else {
        // Because roughjs can only deal with solid colors, we try to calculate
        // the average color of the gradient here.
        // The idea is to create an array of discrete (average) colors that represents the
        // gradient under consideration of the stop's offset. Thus, larger offsets
        // result in more entries of the same mixed color (of the two adjacent color stops).
        // At the end, this array is averaged again, to create a single solid color.
        const resolution = 10;
        const discreteColors = [];
        let lastColor = null;
        for (let i = 0; i < stops.length; i++) {
            const currentColor = getStopColor(stops[i]);
            const currentOffset = getStopOffset(stops[i]);
            // combine the adjacent colors
            const combinedColor = lastColor ? averageColor([lastColor, currentColor]) : currentColor;
            // fill the discrete color array depending on the offset size
            let entries = Math.max(1, (currentOffset / resolution) | 0);
            while (entries > 0) {
                discreteColors.push(combinedColor);
                entries--;
            }
            lastColor = currentColor;
        }
        // average the discrete colors again for the final result
        const mixedColor = averageColor(discreteColors);
        mixedColor.setAlpha(opacity);
        return mixedColor.toString();
    }
}
/**
 * Returns the `stop-color` of an `SVGStopElement`.
 */
function getStopColor(stop) {
    var _a;
    let stopColorStr = stop.getAttribute('stop-color');
    if (!stopColorStr) {
        const style = (_a = stop.getAttribute('style')) !== null && _a !== void 0 ? _a : '';
        const match = /stop-color:\s?(.*);?/.exec(style);
        if (match && match.length > 1) {
            stopColorStr = match[1];
        }
    }
    return stopColorStr ? tinycolor(stopColorStr) : tinycolor('white');
}
/**
 * Calculates the average color of the colors in the given array.
 * @returns The average color
 */
function averageColor(colorArray) {
    const count = colorArray.length;
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    colorArray.forEach(tinycolor => {
        const color = tinycolor.toRgb();
        r += color.r * color.r;
        g += color.g * color.g;
        b += color.b * color.b;
        a += color.a;
    });
    return tinycolor({
        r: Math.sqrt(r / count),
        g: Math.sqrt(g / count),
        b: Math.sqrt(b / count),
        a: a / count
    });
}
/**
 * Returns the `offset` of an `SVGStopElement`.
 * @return stop percentage
 */
function getStopOffset(stop) {
    const offset = stop.getAttribute('offset');
    if (!offset) {
        return 0;
    }
    if (offset.indexOf('%')) {
        return parseFloat(offset.substring(0, offset.length - 1));
    }
    else {
        return parseFloat(offset) * 100;
    }
}

function getPenConfiguration(fillStyle) {
    // the svg2roughjs v2 config
    const legacyConfig = {
        angle: {
            normal: [-30, -50],
            horizontal: [-30, -50],
            vertical: [-30, -50]
        },
        weight: {
            normal: [0.5, 3],
            small: [0.5, 3]
        },
        gap: {
            normal: [3, 5],
            small: [3, 5]
        }
    };
    // adjusted config for more variation
    const defaultConfig = {
        angle: {
            // just lean more into the direction of the aspect ratio
            normal: [-30, -50],
            horizontal: [-50, -75],
            vertical: [-30, -15]
        },
        weight: {
            normal: [1, 3],
            small: [0.5, 1.7]
        },
        gap: {
            normal: [2, 5],
            small: [1, 3]
        }
    };
    // fine-tune configs depending on fill-style
    switch (fillStyle) {
        default:
            return defaultConfig;
        case 'zigzag':
        case 'zigzag-line':
            return Object.assign(Object.assign({}, defaultConfig), { weight: { normal: [0.5, 3], small: [0.5, 2] }, gap: { normal: [2, 6], small: [2, 5] } });
        case 'cross-hatch':
            return Object.assign(Object.assign({}, defaultConfig), { weight: { normal: [1, 3], small: [0.5, 1.3] }, gap: { normal: [4, 8], small: [2, 5] } });
        case 'dots':
            return legacyConfig;
    }
}
/**
 * Creates a random rendering configuration for the given element.
 * The returned pen is specific of the `config.fillStyle` and the element's shape.
 */
function createPen(context, element) {
    if (context.roughConfig.fillStyle === 'solid') {
        // config doesn't affect drawing
        return { angle: 0, gap: 0, weight: 0 };
    }
    // Only works when the element is in the DOM, but no need to check it here,
    // since the related methods can cope with non-finite or zero cases.
    const { width, height } = element.getBoundingClientRect();
    const aspectRatio = width / height;
    const sideLength = Math.sqrt(width * height);
    const { angle, gap, weight } = getPenConfiguration(context.roughConfig.fillStyle);
    return {
        angle: getHachureAngle(context, angle, aspectRatio),
        gap: getHachureGap(context, gap, sideLength),
        weight: getFillWeight(context, weight, sideLength)
    };
}
/**
 * Returns a random hachure angle in the range of the given config.
 *
 * Rough.js default is -41deg
 */
function getHachureAngle({ rng }, { normal, horizontal, vertical }, aspectRatio) {
    if (isFinite(aspectRatio)) {
        // sketch elements along the smaller side
        if (aspectRatio < 0.25) {
            return rng.next(horizontal);
        }
        else if (aspectRatio > 6) {
            return rng.next(vertical);
        }
    }
    return rng.next(normal);
}
/**
 * Returns a random hachure gap in the range of the given config.
 *
 * Rough.js default is 4 * strokeWidth
 */
function getHachureGap({ rng }, { normal, small }, sideLength) {
    return sideLength < 45 ? rng.next(small) : rng.next(normal);
}
/**
 * Returns a random fill weight in the range of the given config.
 *
 * Rough.js default is 0.5 * strokeWidth
 */
function getFillWeight({ rng }, { normal, small }, sideLength) {
    return sideLength < 45 ? rng.next(small) : rng.next(normal);
}

/**
 * Converts the effective style attributes of the given `SVGElement`
 * to a Rough.js config object that is used to draw the element with
 * Rough.js.
 * @return config for Rough.js drawing
 */
function parseStyleConfig(context, element, svgTransform) {
    var _a;
    const precision = (_a = context.roughConfig.fixedDecimalPlaceDigits) !== null && _a !== void 0 ? _a : 15;
    const config = Object.assign({}, context.roughConfig);
    // Scalefactor for certain style attributes. For lack of a better option here, use the determinant
    let scaleFactor = 1;
    if (!isIdentityTransform(svgTransform)) {
        const m = svgTransform.matrix;
        const det = m.a * m.d - m.c * m.b;
        scaleFactor = Math.sqrt(Math.abs(det));
    }
    // incorporate the elements base opacity
    const elementOpacity = getEffectiveElementOpacity(context, element, 1, context.useElementContext);
    const fill = getEffectiveAttribute(context, element, 'fill', context.useElementContext) || 'black';
    const fillOpacity = elementOpacity * getOpacity(element, 'fill-opacity');
    if (fill) {
        if (fill.indexOf('url') !== -1) {
            const gradientColor = convertGradient(context, fill, fillOpacity);
            if (gradientColor !== 'none') {
                config.fill = gradientColor;
            }
            else {
                // delete fill, otherwise it may create an invisible 'hachure' element
                delete config.fill;
            }
        }
        else if (fill === 'none') {
            // delete fill, otherwise it may create an invisible 'hachure' element
            delete config.fill;
        }
        else {
            const color = tinycolor(fill);
            color.setAlpha(fillOpacity);
            config.fill = color.toString();
        }
    }
    const stroke = getEffectiveAttribute(context, element, 'stroke', context.useElementContext);
    const strokeOpacity = elementOpacity * getOpacity(element, 'stroke-opacity');
    if (stroke) {
        if (stroke.indexOf('url') !== -1) {
            config.stroke = convertGradient(context, stroke, strokeOpacity);
        }
        else if (stroke === 'none') {
            config.stroke = 'none';
        }
        else {
            const color = tinycolor(stroke);
            color.setAlpha(strokeOpacity);
            config.stroke = color.toString();
        }
    }
    else {
        config.stroke = 'none';
    }
    const strokeWidth = getEffectiveAttribute(context, element, 'stroke-width', context.useElementContext);
    if (strokeWidth) {
        // Convert to user space units (px)
        const scaledWidth = convertToPixelUnit(context, element, strokeWidth, 'stroke-width') * scaleFactor;
        config.strokeWidth = parseFloat(scaledWidth.toFixed(precision));
    }
    else {
        // default stroke-width is 1
        config.strokeWidth = 1;
    }
    const strokeDashArray = getEffectiveAttribute(context, element, 'stroke-dasharray', context.useElementContext);
    if (strokeDashArray && strokeDashArray !== 'none') {
        config.strokeLineDash = strokeDashArray
            .split(/[\s,]+/)
            .filter(entry => entry.length > 0)
            // make sure that dashes/dots are at least somewhat visible
            .map(dash => {
            const scaledLineDash = convertToPixelUnit(context, element, dash, 'stroke-dasharray') * scaleFactor;
            return Math.max(0.5, parseFloat(scaledLineDash.toFixed(precision)));
        });
    }
    const strokeDashOffset = getEffectiveAttribute(context, element, 'stroke-dashoffset', context.useElementContext);
    if (strokeDashOffset) {
        const scaledOffset = convertToPixelUnit(context, element, strokeDashOffset, 'stroke-dashoffset') * scaleFactor;
        config.strokeLineDashOffset = parseFloat(scaledOffset.toFixed(precision));
    }
    // unstroked but filled shapes look weird, so always apply a stroke if we fill something
    if (config.fill && config.stroke === 'none') {
        config.stroke = config.fill;
        config.strokeWidth = 1;
    }
    if (context.randomize) {
        const { angle, gap, weight } = createPen(context, element);
        config.hachureAngle = angle;
        config.hachureGap = Math.round(gap); // must be integer (avg gap in pixels)
        config.fillWeight = parseFloat(weight.toFixed(precision)); // value is used in the sketched output as-is
        // randomize double stroke effect if not explicitly set through user config
        if (typeof config.disableMultiStroke === 'undefined') {
            config.disableMultiStroke = context.rng.next() > 0.3;
        }
    }
    return config;
}
/**
 * Converts SVG opacity attributes to a [0, 1] range.
 */
function getOpacity(element, attribute) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const attr = getComputedStyle(element)[attribute] || element.getAttribute(attribute);
    if (attr) {
        if (attr.indexOf('%') !== -1) {
            return Math.min(1, Math.max(0, parseFloat(attr.substring(0, attr.length - 1)) / 100));
        }
        return Math.min(1, Math.max(0, parseFloat(attr)));
    }
    return 1;
}
/**
 * Parses a `fill` url by looking in the SVG `defs` element.
 * When a gradient is found, it is converted to a color and stored
 * in the internal defs store for this url.
 *
 * Patterns are ignored and returned with 'none'.
 *
 * @returns The parsed color
 */
function convertGradient(context, url, opacity) {
    const id = getIdFromUrl(url);
    if (!id) {
        return 'none';
    }
    const paint = context.idElements[id];
    if (!paint) {
        return 'none';
    }
    if (typeof paint === 'string') {
        // maybe it was already parsed and replaced with a color
        return paint;
    }
    else if (paint instanceof SVGLinearGradientElement ||
        paint instanceof SVGRadialGradientElement) {
        const color = gradientToColor(paint, opacity);
        context.idElements[id] = color;
        return color;
    }
    else {
        // pattern or something else that cannot be directly used in the roughjs config
        return 'none';
    }
}
function isHidden(element) {
    const style = element.style;
    if (!style) {
        return false;
    }
    return style.display === 'none' || style.visibility === 'hidden';
}
function concatStyleStrings(...args) {
    let ret = '';
    args = args.filter(s => s !== null);
    for (const style of args) {
        if (ret.length > 0 && ret[ret.length - 1] !== ';') {
            ret += ';';
        }
        ret += style;
    }
    return ret;
}

function str(p) {
    return `${p.x},${p.y}`;
}
function equals(p0, p1) {
    return p0.x === p1.x && p0.y === p1.y;
}

function drawCircle(context, circle, svgTransform) {
    const cx = circle.cx.baseVal.value;
    const cy = circle.cy.baseVal.value;
    const r = circle.r.baseVal.value;
    if (r === 0) {
        // zero-radius circle is not rendered
        return;
    }
    const center = applyMatrix({ x: cx, y: cy }, svgTransform);
    const radiusPoint = applyMatrix({ x: cx + r, y: cy + r }, svgTransform);
    const transformedRadius = radiusPoint.x - center.x;
    let result;
    if (isIdentityTransform(svgTransform) || isTranslationTransform(svgTransform)) {
        // transform a point on the ellipse to get the transformed radius
        result = context.rc.circle(center.x, center.y, 2 * transformedRadius, Object.assign(Object.assign({}, parseStyleConfig(context, circle, svgTransform)), { preserveVertices: true }));
    }
    else {
        // in other cases we need to construct the path manually.
        const factor = (4 / 3) * (Math.sqrt(2) - 1);
        const p1 = applyMatrix({ x: cx + r, y: cy }, svgTransform);
        const p2 = applyMatrix({ x: cx, y: cy + r }, svgTransform);
        const p3 = applyMatrix({ x: cx - r, y: cy }, svgTransform);
        const p4 = applyMatrix({ x: cx, y: cy - r }, svgTransform);
        const c1 = applyMatrix({ x: cx + r, y: cy + factor * r }, svgTransform);
        const c2 = applyMatrix({ x: cx + factor * r, y: cy + r }, svgTransform);
        const c4 = applyMatrix({ x: cx - r, y: cy + factor * r }, svgTransform);
        const c6 = applyMatrix({ x: cx - factor * r, y: cy - r }, svgTransform);
        const c8 = applyMatrix({ x: cx + r, y: cy - factor * r }, svgTransform);
        const path = `M ${str(p1)} C ${str(c1)} ${str(c2)} ${str(p2)} S ${str(c4)} ${str(p3)} S ${str(c6)} ${str(p4)} S ${str(c8)} ${str(p1)}z`;
        result = sketchPath(context, path, parseStyleConfig(context, circle, svgTransform));
    }
    appendPatternPaint(context, circle, () => {
        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        proxy.cx.baseVal.value = center.x;
        proxy.cy.baseVal.value = center.y;
        proxy.r.baseVal.value = transformedRadius;
        return proxy;
    });
    appendSketchElement(context, circle, result);
}
function applyCircleClip(context, circle, container, svgTransform) {
    const cx = circle.cx.baseVal.value;
    const cy = circle.cy.baseVal.value;
    const r = circle.r.baseVal.value;
    if (r === 0) {
        // zero-radius circle is not rendered
        return;
    }
    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    clip.cx.baseVal.value = cx;
    clip.cy.baseVal.value = cy;
    clip.r.baseVal.value = r;
    applyTransform(context, svgTransform, clip);
    container.appendChild(clip);
}

function drawEllipse(context, ellipse, svgTransform) {
    const cx = ellipse.cx.baseVal.value;
    const cy = ellipse.cy.baseVal.value;
    const rx = ellipse.rx.baseVal.value;
    const ry = ellipse.ry.baseVal.value;
    if (rx === 0 || ry === 0) {
        // zero-radius ellipse is not rendered
        return;
    }
    const center = applyMatrix({ x: cx, y: cy }, svgTransform);
    // transform a point on the ellipse to get the transformed radius
    const radiusPoint = applyMatrix({ x: cx + rx, y: cy + ry }, svgTransform);
    const transformedRx = radiusPoint.x - center.x;
    const transformedRy = radiusPoint.y - center.y;
    let result;
    if (isIdentityTransform(svgTransform) || isTranslationTransform(svgTransform)) {
        // Simple case, there's no transform and we can use the ellipse command
        result = context.rc.ellipse(center.x, center.y, 2 * transformedRx, 2 * transformedRy, Object.assign(Object.assign({}, parseStyleConfig(context, ellipse, svgTransform)), { preserveVertices: true }));
    }
    else {
        // in other cases we need to construct the path manually.
        const factor = (4 / 3) * (Math.sqrt(2) - 1);
        const p1 = applyMatrix({ x: cx + rx, y: cy }, svgTransform);
        const p2 = applyMatrix({ x: cx, y: cy + ry }, svgTransform);
        const p3 = applyMatrix({ x: cx - rx, y: cy }, svgTransform);
        const p4 = applyMatrix({ x: cx, y: cy - ry }, svgTransform);
        const c1 = applyMatrix({ x: cx + rx, y: cy + factor * ry }, svgTransform);
        const c2 = applyMatrix({ x: cx + factor * rx, y: cy + ry }, svgTransform);
        const c4 = applyMatrix({ x: cx - rx, y: cy + factor * ry }, svgTransform);
        const c6 = applyMatrix({ x: cx - factor * rx, y: cy - ry }, svgTransform);
        const c8 = applyMatrix({ x: cx + rx, y: cy - factor * ry }, svgTransform);
        const path = `M ${str(p1)} C ${str(c1)} ${str(c2)} ${str(p2)} S ${str(c4)} ${str(p3)} S ${str(c6)} ${str(p4)} S ${str(c8)} ${str(p1)}z`;
        result = sketchPath(context, path, parseStyleConfig(context, ellipse, svgTransform));
    }
    appendPatternPaint(context, ellipse, () => {
        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
        proxy.cx.baseVal.value = center.x;
        proxy.cy.baseVal.value = center.y;
        proxy.rx.baseVal.value = transformedRx;
        proxy.ry.baseVal.value = transformedRy;
        return proxy;
    });
    appendSketchElement(context, ellipse, result);
}
function applyEllipseClip(context, ellipse, container, svgTransform) {
    const cx = ellipse.cx.baseVal.value;
    const cy = ellipse.cy.baseVal.value;
    const rx = ellipse.rx.baseVal.value;
    const ry = ellipse.ry.baseVal.value;
    if (rx === 0 || ry === 0) {
        // zero-radius ellipse is not rendered
        return;
    }
    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
    clip.cx.baseVal.value = cx;
    clip.cy.baseVal.value = cy;
    clip.rx.baseVal.value = rx;
    clip.ry.baseVal.value = ry;
    applyTransform(context, svgTransform, clip);
    container.appendChild(clip);
}

function drawMarkers(context, element, points, svgTransform) {
    if (points.length === 0) {
        return;
    }
    const startPt = points[0];
    const endPt = points[points.length - 1];
    // start marker
    const markerStartId = getIdFromUrl(element.getAttribute('marker-start'));
    const markerStartElement = markerStartId
        ? context.idElements[markerStartId]
        : null;
    // marker-start is only rendered when there are at least two points
    if (markerStartElement && points.length > 1) {
        let angle = markerStartElement.orientAngle.baseVal.value;
        const nextPt = points[1];
        const orientAttr = markerStartElement.getAttribute('orient');
        if (orientAttr === 'auto' || orientAttr === 'auto-start-reverse') {
            const reverse = orientAttr === 'auto' ? 0 : 180;
            const prevPt = points[points.length - 2];
            if (isClosedPath(points)) {
                // https://www.w3.org/TR/SVG11/painting.html#OrientAttribute
                // use angle bisector of incoming and outgoing angle
                angle = getBisectingAngle(prevPt, endPt, nextPt) - reverse;
            }
            else {
                const vOut = { x: nextPt.x - startPt.x, y: nextPt.y - startPt.y };
                angle = getAngle({ x: 1, y: 0 }, vOut) - reverse;
            }
        }
        const matrix = context.sourceSvg
            .createSVGMatrix()
            .translate(startPt.x, startPt.y)
            .rotate(angle)
            .scale(getScaleFactor(context, markerStartElement, element));
        const combinedMatrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;
        const markerTransform = context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);
        context.processElement(context, markerStartElement, markerTransform);
    }
    // end marker
    const markerEndId = getIdFromUrl(element.getAttribute('marker-end'));
    const markerEndElement = markerEndId
        ? context.idElements[markerEndId]
        : null;
    // marker-end is also rendered if the path has only one point
    if (markerEndElement) {
        let angle = markerEndElement.orientAngle.baseVal.value;
        if (points.length > 1) {
            const orientAttr = markerEndElement.getAttribute('orient');
            if (orientAttr === 'auto' || orientAttr === 'auto-start-reverse') {
                // by spec, "auto-start-reverse" has no effect on marker end
                const prevPt = points[points.length - 2];
                if (isClosedPath(points)) {
                    // https://www.w3.org/TR/SVG11/painting.html#OrientAttribute
                    // use angle bisector of incoming and outgoing angle
                    const nextPt = points[1]; // start and end points are equal, take second point
                    angle = getBisectingAngle(prevPt, endPt, nextPt);
                }
                else {
                    const vIn = { x: endPt.x - prevPt.x, y: endPt.y - prevPt.y };
                    angle = getAngle({ x: 1, y: 0 }, vIn);
                }
            }
        }
        const matrix = context.sourceSvg
            .createSVGMatrix()
            .translate(endPt.x, endPt.y)
            .rotate(angle)
            .scale(getScaleFactor(context, markerEndElement, element));
        const combinedMatrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;
        const markerTransform = context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);
        context.processElement(context, markerEndElement, markerTransform);
    }
    // mid marker(s)
    const markerMidId = getIdFromUrl(element.getAttribute('marker-mid'));
    const markerMidElement = markerMidId
        ? context.idElements[markerMidId]
        : null;
    if (markerMidElement && points.length > 2) {
        for (let i = 0; i < points.length; i++) {
            const loc = points[i];
            if (i === 0 || i === points.length - 1) {
                // mid markers are not drawn on first or last point
                continue;
            }
            let angle = markerMidElement.orientAngle.baseVal.value;
            const orientAttr = markerMidElement.getAttribute('orient');
            if (orientAttr === 'auto' || orientAttr === 'auto-start-reverse') {
                // by spec, "auto-start-reverse" has no effect on marker mid
                const prevPt = points[i - 1];
                const nextPt = points[i + 1];
                // https://www.w3.org/TR/SVG11/painting.html#OrientAttribute
                // use angle bisector of incoming and outgoing angle
                angle = getBisectingAngle(prevPt, loc, nextPt);
            }
            const matrix = context.sourceSvg
                .createSVGMatrix()
                .translate(loc.x, loc.y)
                .rotate(angle)
                .scale(getScaleFactor(context, markerMidElement, element));
            const combinedMatrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;
            const markerTransform = context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);
            context.processElement(context, markerMidElement, markerTransform);
        }
    }
}
/**
 * Consider scaled coordinate system for markerWidth/markerHeight.
 */
function getScaleFactor(context, marker, referrer) {
    const markerUnits = marker.getAttribute('markerUnits');
    let scaleFactor = 1;
    if (!markerUnits || markerUnits === 'strokeWidth') {
        // default is strokeWidth by SVG spec
        const strokeWidth = getEffectiveAttribute(context, referrer, 'stroke-width');
        if (strokeWidth) {
            scaleFactor = convertToPixelUnit(context, referrer, strokeWidth, 'stroke-width');
        }
    }
    return scaleFactor;
}
/**
 * Whether the path is closed, i.e. the start and end points are identical
 */
function isClosedPath(points) {
    return equals(points[0], points[points.length - 1]);
}
/**
 * Returns the bisection angle of the angle that is spanned by the given points.
 * @param prevPt The point from which the incoming flank is pointing
 * @param crossingPt The anchor point of the angle
 * @param nextPt Th point to which the outgoing flank is pointing
 * @returns The bisecting angle
 */
function getBisectingAngle(prevPt, crossingPt, nextPt) {
    const vIn = { x: nextPt.x - crossingPt.x, y: nextPt.y - crossingPt.y };
    const vOut = { x: prevPt.x - crossingPt.x, y: prevPt.y - crossingPt.y };
    // the relative angle between the two vectors
    const vectorAngle = getAngle(vIn, vOut);
    // calculate the absolute angle of the vectors considering the x-axis as reference
    const refPoint = { x: crossingPt.x + 1, y: crossingPt.y };
    const refVector = { x: refPoint.x - crossingPt.x, y: refPoint.y - crossingPt.y };
    const refAngle = getAngle(vIn, refVector);
    // return the absolute bisector
    return getOppositeAngle(vectorAngle) / 2 - refAngle;
}
/**
 * Returns the opposite angle of the line. Considers the direction of the angle
 * (i.e. positive for clockwise, negative for counter-clickwise).
 */
function getOppositeAngle(angle) {
    return angle - Math.sign(angle) * 180;
}
/**
 * Returns the signed angle between the vectors (i.e. positive for clockwise,
 * negative for counter-clickwise).
 * @param v1 2-dimensional vector
 * @param v2 2-dimensional vector
 * @returns The signed angle between the vectors
 */
function getAngle(v1, v2) {
    const a1 = Math.atan2(v1.y, v1.x);
    const a2 = Math.atan2(v2.y, v2.x);
    const angle = a2 - a1;
    const K = -Math.sign(angle) * Math.PI * 2;
    const a = Math.abs(K + angle) < Math.abs(angle) ? K + angle : angle;
    return Math.round((360 * a) / (Math.PI * 2));
}

function drawPath(context, path, svgTransform) {
    const dataAttrs = path.getAttribute('d');
    const pathData = 
    // Parse path data and convert to absolute coordinates
    new SVGPathData(dataAttrs)
        .toAbs()
        // Normalize H and V to L commands - those cannot work with how we draw transformed paths otherwise
        .transform(SVGPathDataTransformer.NORMALIZE_HVZ())
        // Normalize S and T to Q and C commands - Rough.js has a bug with T where it expects 4 parameters instead of 2
        .transform(SVGPathDataTransformer.NORMALIZE_ST());
    // If there's a transform, transform the whole path accordingly
    const transformedPathData = new SVGPathData(
    // clone the commands, we might need them untransformed for markers
    pathData.commands.map(cmd => Object.assign({}, cmd)));
    if (svgTransform) {
        transformedPathData.transform(SVGPathDataTransformer.MATRIX(svgTransform.matrix.a, svgTransform.matrix.b, svgTransform.matrix.c, svgTransform.matrix.d, svgTransform.matrix.e, svgTransform.matrix.f));
    }
    const encodedPathData = encodeSVGPath(transformedPathData.commands);
    if (encodedPathData.indexOf('undefined') !== -1) {
        // DEBUG STUFF
        console.error('broken path data');
        return;
    }
    const pathSketch = sketchPath(context, encodedPathData, parseStyleConfig(context, path, svgTransform));
    appendPatternPaint(context, path, () => {
        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        proxy.setAttribute('d', encodedPathData);
        return proxy;
    });
    appendSketchElement(context, path, pathSketch);
    // https://www.w3.org/TR/SVG11/painting.html#MarkerProperties
    // Note that for a path element which ends with a closed sub-path,
    // the last vertex is the same as the initial vertex on the given
    // sub-path (same applies to polygon).
    const points = [];
    let currentSubPathBegin;
    pathData.commands.forEach(cmd => {
        switch (cmd.type) {
            case SVGPathData.MOVE_TO: {
                const p = { x: cmd.x, y: cmd.y };
                points.push(p);
                // each moveto starts a new subpath
                currentSubPathBegin = p;
                break;
            }
            case SVGPathData.LINE_TO:
            case SVGPathData.QUAD_TO:
            case SVGPathData.SMOOTH_QUAD_TO:
            case SVGPathData.CURVE_TO:
            case SVGPathData.SMOOTH_CURVE_TO:
            case SVGPathData.ARC:
                points.push({ x: cmd.x, y: cmd.y });
                break;
            case SVGPathData.HORIZ_LINE_TO:
                points.push({ x: cmd.x, y: 0 });
                break;
            case SVGPathData.VERT_LINE_TO:
                points.push({ x: 0, y: cmd.y });
                break;
            case SVGPathData.CLOSE_PATH:
                if (currentSubPathBegin) {
                    points.push(currentSubPathBegin);
                }
                break;
        }
    });
    drawMarkers(context, path, points, svgTransform);
}
function applyPathClip(context, path, container, svgTransform) {
    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    clip.setAttribute('d', path.getAttribute('d'));
    applyTransform(context, svgTransform, clip);
    container.appendChild(clip);
}

function drawPolygon(context, polygon, svgTransform) {
    const points = getPointsArray(polygon);
    const transformed = points.map(p => {
        const pt = applyMatrix(p, svgTransform);
        return [pt.x, pt.y];
    });
    const polygonSketch = context.rc.polygon(transformed, parseStyleConfig(context, polygon, svgTransform));
    appendPatternPaint(context, polygon, () => {
        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        proxy.setAttribute('points', transformed.join(' '));
        return proxy;
    });
    appendSketchElement(context, polygon, polygonSketch);
    // https://www.w3.org/TR/SVG11/painting.html#MarkerProperties
    // Note that for a path element which ends with a closed sub-path,
    // the last vertex is the same as the initial vertex on the given
    // sub-path (same applies to polygon).
    if (points.length > 0) {
        points.push(points[0]);
        drawMarkers(context, polygon, points, svgTransform);
    }
}
function applyPolygonClip(context, polygon, container, svgTransform) {
    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    clip.setAttribute('points', polygon.getAttribute('points'));
    applyTransform(context, svgTransform, clip);
    container.appendChild(clip);
}

function drawRect(context, rect, svgTransform) {
    const x = rect.x.baseVal.value;
    const y = rect.y.baseVal.value;
    const width = rect.width.baseVal.value;
    const height = rect.height.baseVal.value;
    if (width === 0 || height === 0) {
        // zero-width or zero-height rect will not be rendered
        return;
    }
    // Negative values are an error and result in the default value, and clamp both values to half their sides' lengths
    let rx = rect.hasAttribute('rx') ? Math.min(Math.max(0, rect.rx.baseVal.value), width / 2) : null;
    let ry = rect.hasAttribute('ry') ? Math.min(Math.max(0, rect.ry.baseVal.value), height / 2) : null;
    if (rx !== null || ry !== null) {
        // If only one of the two values is specified, the other has the same value
        rx = rx === null ? ry : rx;
        ry = ry === null ? rx : ry;
    }
    // the transformed, rectangular bounds
    const p1 = applyMatrix({ x, y }, svgTransform);
    const p2 = applyMatrix({ x: x + width, y: y + height }, svgTransform);
    const transformedWidth = p2.x - p1.x;
    const transformedHeight = p2.y - p1.y;
    const transformedBounds = { x: p1.x, y: p1.y, w: transformedWidth, h: transformedHeight };
    if ((isIdentityTransform(svgTransform) || isTranslationTransform(svgTransform)) && !rx && !ry) {
        // Simple case; just a rectangle
        const sketchRect = context.rc.rectangle(transformedBounds.x, transformedBounds.y, transformedBounds.w, transformedBounds.h, parseStyleConfig(context, rect, svgTransform));
        applyPatternPaint(context, rect, transformedBounds);
        appendSketchElement(context, rect, sketchRect);
    }
    else {
        let path = '';
        if (rx !== null && ry !== null) {
            const factor = (4 / 3) * (Math.sqrt(2) - 1);
            // Construct path for the rounded rectangle
            // perform an absolute moveto operation to location (x+rx,y), where x is the value of the rect element's x attribute converted to user space, rx is the effective value of the rx attribute converted to user space and y is the value of the y attribute converted to user space
            const p1 = applyMatrix({ x: x + rx, y }, svgTransform);
            path += `M ${str(p1)}`;
            // perform an absolute horizontal lineto operation to location (x+width-rx,y), where width is the rect element's width attribute converted to user space
            const p2 = applyMatrix({ x: x + width - rx, y }, svgTransform);
            path += `L ${str(p2)}`;
            // perform an absolute elliptical arc operation to coordinate (x+width,y+ry), where the effective values for the rx and ry attributes on the rect element converted to user space are used as the rx and ry attributes on the elliptical arc command, respectively, the x-axis-rotation is set to zero, the large-arc-flag is set to zero, and the sweep-flag is set to one
            const p3c1 = applyMatrix({ x: x + width - rx + factor * rx, y }, svgTransform);
            const p3c2 = applyMatrix({ x: x + width, y: y + factor * ry }, svgTransform);
            const p3 = applyMatrix({ x: x + width, y: y + ry }, svgTransform);
            path += `C ${str(p3c1)} ${str(p3c2)} ${str(p3)}`; // We cannot use the arc command, since we no longer draw in the expected coordinates. So approximate everything with lines and bziers
            // perform a absolute vertical lineto to location (x+width,y+height-ry), where height is the rect element's height attribute converted to user space
            const p4 = applyMatrix({ x: x + width, y: y + height - ry }, svgTransform);
            path += `L ${str(p4)}`;
            // perform an absolute elliptical arc operation to coordinate (x+width-rx,y+height)
            const p5c1 = applyMatrix({ x: x + width, y: y + height - ry + factor * ry }, svgTransform);
            const p5c2 = applyMatrix({ x: x + width - factor * rx, y: y + height }, svgTransform);
            const p5 = applyMatrix({ x: x + width - rx, y: y + height }, svgTransform);
            path += `C ${str(p5c1)} ${str(p5c2)} ${str(p5)}`;
            // perform an absolute horizontal lineto to location (x+rx,y+height)
            const p6 = applyMatrix({ x: x + rx, y: y + height }, svgTransform);
            path += `L ${str(p6)}`;
            // perform an absolute elliptical arc operation to coordinate (x,y+height-ry)
            const p7c1 = applyMatrix({ x: x + rx - factor * rx, y: y + height }, svgTransform);
            const p7c2 = applyMatrix({ x, y: y + height - factor * ry }, svgTransform);
            const p7 = applyMatrix({ x, y: y + height - ry }, svgTransform);
            path += `C ${str(p7c1)} ${str(p7c2)} ${str(p7)}`;
            // perform an absolute absolute vertical lineto to location (x,y+ry)
            const p8 = applyMatrix({ x, y: y + ry }, svgTransform);
            path += `L ${str(p8)}`;
            // perform an absolute elliptical arc operation to coordinate (x+rx,y)
            const p9c1 = applyMatrix({ x, y: y + factor * ry }, svgTransform);
            const p9c2 = applyMatrix({ x: x + factor * rx, y }, svgTransform);
            path += `C ${str(p9c1)} ${str(p9c2)} ${str(p1)}`;
            path += 'z';
        }
        else {
            // No rounding, so just construct the respective path as a simple polygon
            const p1 = applyMatrix({ x, y }, svgTransform);
            const p2 = applyMatrix({ x: x + width, y }, svgTransform);
            const p3 = applyMatrix({ x: x + width, y: y + height }, svgTransform);
            const p4 = applyMatrix({ x, y: y + height }, svgTransform);
            path += `M ${str(p1)}`;
            path += `L ${str(p2)}`;
            path += `L ${str(p3)}`;
            path += `L ${str(p4)}`;
            path += `z`;
        }
        const result = sketchPath(context, path, parseStyleConfig(context, rect, svgTransform));
        applyPatternPaint(context, rect, transformedBounds);
        appendSketchElement(context, rect, result);
    }
}
function applyPatternPaint(context, rect, { x, y, w, h }) {
    appendPatternPaint(context, rect, () => {
        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        proxy.x.baseVal.value = x;
        proxy.y.baseVal.value = y;
        proxy.width.baseVal.value = w;
        proxy.height.baseVal.value = h;
        return proxy;
    });
}
function applyRectClip(context, rect, container, svgTransform) {
    const x = rect.x.baseVal.value;
    const y = rect.y.baseVal.value;
    const width = rect.width.baseVal.value;
    const height = rect.height.baseVal.value;
    if (width === 0 || height === 0) {
        // zero-width or zero-height rect will not be rendered
        return;
    }
    const rx = rect.hasAttribute('rx') ? rect.rx.baseVal.value : null;
    const ry = rect.hasAttribute('ry') ? rect.ry.baseVal.value : null;
    const clip = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    clip.x.baseVal.value = x;
    clip.y.baseVal.value = y;
    clip.width.baseVal.value = width;
    clip.height.baseVal.value = height;
    if (rx) {
        clip.rx.baseVal.value = rx;
    }
    if (ry) {
        clip.ry.baseVal.value = ry;
    }
    applyTransform(context, svgTransform, clip);
    container.appendChild(clip);
}

/**
 * Applies the clip-path to the CanvasContext.
 */
function applyClipPath(context, owner, clipPathAttr, svgTransform) {
    const id = getIdFromUrl(clipPathAttr);
    if (!id) {
        return;
    }
    const clipPath = context.idElements[id];
    if (!clipPath) {
        return;
    }
    // TODO clipPath: consider clipPathUnits
    //  create clipPath defs
    const targetDefs = getDefsElement(context);
    // unfortunately, we cannot reuse clip-paths due to the 'global transform' approach
    const sketchClipPathId = `${id}_${targetDefs.childElementCount}`;
    const clipContainer = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
    clipContainer.id = sketchClipPathId;
    storeSketchClipId(owner, sketchClipPathId);
    // traverse clip-path elements in DFS
    const stack = [];
    const children = getNodeChildren(clipPath);
    for (let i = children.length - 1; i >= 0; i--) {
        const childElement = children[i];
        const childTransform = getCombinedTransform(context, childElement, svgTransform);
        stack.push({ element: childElement, transform: childTransform });
    }
    while (stack.length > 0) {
        const { element, transform } = stack.pop();
        try {
            applyElementClip(context, element, clipContainer, transform);
        }
        catch (e) {
            console.error(e);
        }
        if (element.tagName === 'defs' ||
            element.tagName === 'svg' ||
            element.tagName === 'clipPath' ||
            element.tagName === 'text') {
            // some elements are ignored on clippaths
            continue;
        }
        // process children
        const children = getNodeChildren(element);
        for (let i = children.length - 1; i >= 0; i--) {
            const childElement = children[i];
            const childTransform = getCombinedTransform(context, childElement, transform);
            stack.push({ element: childElement, transform: childTransform });
        }
    }
    if (clipContainer.childNodes.length > 0) {
        // add the clip-path only if it contains converted elements
        // some elements are not yet supported
        targetDefs.appendChild(clipContainer);
    }
}
/**
 * Creates a clip element and appends it to the given container.
 */
function applyElementClip(context, element, container, svgTransform) {
    switch (element.tagName) {
        case 'rect':
            applyRectClip(context, element, container, svgTransform);
            break;
        case 'circle':
            applyCircleClip(context, element, container, svgTransform);
            break;
        case 'ellipse':
            applyEllipseClip(context, element, container, svgTransform);
            break;
        case 'polygon':
            applyPolygonClip(context, element, container, svgTransform);
            break;
        case 'path':
            applyPathClip(context, element, container, svgTransform);
            break;
    }
}
/**
 * Store clippath-id on each child for <g> elements, or on the owner itself for other
 * elements.
 *
 * <g> elements are skipped in the processing loop, thus the clip-path id must be stored
 * on the child elements.
 */
function storeSketchClipId(element, id) {
    if (element.tagName !== 'g') {
        element.setAttribute(SKETCH_CLIP_ATTRIBUTE, id);
        return;
    }
    const stack = [];
    const children = getNodeChildren(element);
    for (let i = children.length - 1; i >= 0; i--) {
        stack.push(children[i]);
    }
    while (stack.length > 0) {
        const element = stack.pop();
        element.setAttribute(SKETCH_CLIP_ATTRIBUTE, id);
        const children = getNodeChildren(element);
        for (let i = children.length - 1; i >= 0; i--) {
            stack.push(children[i]);
        }
    }
}

function drawForeignObject(context, foreignObject, svgTransform) {
    const foreignObjectClone = foreignObject.cloneNode(true);
    const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    // foreignObject often relies on CSS styling, and just copying the <style> element
    // won't do the trick, because sketching the SVG rebuilds the entire element tree, thus
    // existing CSS rules don't apply anymore in most cases.
    //
    // To to make the MOST SIMPLE cases of foreignObject text elements work better,
    // try to apply the computed style on the new SVG container.
    // To properly fix it, we'd need to inline all computed styles recursively on the
    // foreignObject tree.
    const copyStyleProperties = [
        'color',
        'font-family',
        'font-size',
        'font-style',
        'font-variant',
        'font-weight'
    ];
    const style = getComputedStyle(foreignObject);
    for (const prop of copyStyleProperties) {
        container.style.setProperty(prop, style.getPropertyValue(prop));
    }
    // transform is already considered in svgTransform
    foreignObjectClone.transform.baseVal.clear();
    // transform the foreignObject to its destination location
    applyTransform(context, svgTransform, container);
    container.appendChild(foreignObjectClone);
    appendSketchElement(context, foreignObjectClone, container);
}

function drawImage(context, svgImage, svgTransform) {
    const href = svgImage.href.baseVal;
    const x = svgImage.x.baseVal.value;
    const y = svgImage.y.baseVal.value;
    let width, height;
    if (svgImage.getAttribute('width') && svgImage.getAttribute('height')) {
        width = svgImage.width.baseVal.value;
        height = svgImage.height.baseVal.value;
    }
    if (href.startsWith('data:') && href.indexOf('image/svg+xml') !== -1) {
        // data:[<media type>][;charset=<character set>][;base64],<data>
        const dataUrlRegex = /^data:([^,]*),(.*)/;
        const match = dataUrlRegex.exec(href);
        if (match && match.length > 2) {
            const meta = match[1];
            let svgString = match[2];
            const isBase64 = meta.indexOf('base64') !== -1;
            const isUtf8 = meta.indexOf('utf8') !== -1;
            if (isBase64) {
                svgString = atob(svgString);
            }
            if (!isUtf8) {
                svgString = decodeURIComponent(svgString);
            }
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgString, 'image/svg+xml');
            const svg = doc.firstChild;
            let matrix = context.sourceSvg.createSVGMatrix().translate(x, y);
            matrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;
            context.processElement(context, svg, context.sourceSvg.createSVGTransformFromMatrix(matrix), width, height);
            return;
        }
    }
    else {
        const imageClone = svgImage.cloneNode();
        const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        applyTransform(context, svgTransform, container);
        container.appendChild(imageClone);
        appendSketchElement(context, svgImage, container);
    }
}

function drawLine(context, line, svgTransform) {
    const p1 = { x: line.x1.baseVal.value, y: line.y1.baseVal.value };
    const p2 = { x: line.x2.baseVal.value, y: line.y2.baseVal.value };
    const { x: tp1x, y: tp1y } = applyMatrix(p1, svgTransform);
    const { x: tp2x, y: tp2y } = applyMatrix(p2, svgTransform);
    if (tp1x === tp2x && tp1y === tp2y) {
        // zero-length line is not rendered
        return;
    }
    const lineSketch = context.rc.line(tp1x, tp1y, tp2x, tp2y, parseStyleConfig(context, line, svgTransform));
    appendPatternPaint(context, line, () => {
        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        proxy.x1.baseVal.value = tp1x;
        proxy.y1.baseVal.value = tp1y;
        proxy.x2.baseVal.value = tp2x;
        proxy.y2.baseVal.value = tp2y;
        return proxy;
    });
    appendSketchElement(context, line, lineSketch);
    drawMarkers(context, line, [p1, p2], svgTransform);
}

function drawPolyline(context, polyline, svgTransform) {
    const points = getPointsArray(polyline);
    const transformed = points.map(p => {
        const pt = applyMatrix(p, svgTransform);
        return [pt.x, pt.y];
    });
    const style = parseStyleConfig(context, polyline, svgTransform);
    appendPatternPaint(context, polyline, () => {
        const proxy = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        proxy.setAttribute('points', transformed.join(' '));
        return proxy;
    });
    if (style.fill && style.fill !== 'none') {
        const fillStyle = Object.assign(Object.assign({}, style), { stroke: 'none' });
        appendSketchElement(context, polyline, context.rc.polygon(transformed, fillStyle));
    }
    appendSketchElement(context, polyline, context.rc.linearPath(transformed, style));
    drawMarkers(context, polyline, points, svgTransform);
}

function drawText(context, text, svgTransform) {
    const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    container.setAttribute('class', 'text-container');
    applyTransform(context, svgTransform, container);
    const textClone = text.cloneNode(true);
    if (textClone.transform.baseVal.numberOfItems > 0) {
        // remove transformation, since it is transformed globally by its parent container
        textClone.transform.baseVal.clear();
    }
    // clip-path is applied on the container
    textClone.removeAttribute('clip-path');
    const { cssFont, fontSize: effectiveFontSize } = getCssFont(context, text, true);
    textClone.setAttribute('style', concatStyleStrings(textClone.getAttribute('style'), cssFont));
    copyTextStyleAttributes(context, text, textClone);
    // apply styling to any tspan
    if (textClone.childElementCount > 0) {
        const children = getNodeChildren(textClone);
        const origChildren = getNodeChildren(text);
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child instanceof SVGTSpanElement) {
                copyTextStyleAttributes(context, origChildren[i], child);
            }
        }
    }
    container.appendChild(textClone);
    appendSketchElement(context, text, container);
    // avoid text clipping by scaling the text when changing the font
    const useCustomFontFamily = context.fontFamily !== null;
    const hasClipPath = textClone.hasAttribute(SKETCH_CLIP_ATTRIBUTE);
    if (useCustomFontFamily && hasClipPath && effectiveFontSize) {
        fitFontSize(context, text, textClone, effectiveFontSize);
    }
}
/**
 * Applies a font-size on the clone such that the clone has a smaller width than the original element.
 * Only fits the width because the height is usually no problem wrt. clipping.
 */
function fitFontSize(context, original, clone, effectiveFontSize) {
    const { width, height } = original.getBBox();
    if (width <= 0 || height <= 0) {
        return;
    }
    const fontSizePx = convertToPixelUnit(context, clone, effectiveFontSize, 'font-size');
    fitFontSizeCore(context, { w: width, h: height }, clone, fontSizePx);
}
/**
 * Recursively shrinks the font-size on the element until its width is smaller than the original width.
 */
function fitFontSizeCore(context, originalSize, clone, fontSizePx) {
    const STEP_SIZE = 1;
    const { w: cloneWidth } = measureText(context, clone);
    if (cloneWidth < originalSize.w) {
        // fits original width
        return;
    }
    if (fontSizePx <= 1) {
        // already too small
        return;
    }
    // try a smaller size
    const newFontSize = fontSizePx - STEP_SIZE;
    clone.style.fontSize = `${newFontSize}px`;
    // check again
    fitFontSizeCore(context, originalSize, clone, newFontSize);
}
/**
 * @param asStyleString Formats the return value as inline style string
 */
function getCssFont(context, text, asStyleString = false) {
    const effectiveAttributes = {};
    let cssFont = '';
    const fontStyle = getEffectiveAttribute(context, text, 'font-style', context.useElementContext);
    if (fontStyle) {
        cssFont += asStyleString ? `font-style: ${fontStyle};` : fontStyle;
        effectiveAttributes.fontStyle = fontStyle;
    }
    const fontWeight = getEffectiveAttribute(context, text, 'font-weight', context.useElementContext);
    if (fontWeight) {
        cssFont += asStyleString ? `font-weight: ${fontWeight};` : ` ${fontWeight}`;
        effectiveAttributes.fontWeight = fontWeight;
    }
    const fontSize = getEffectiveAttribute(context, text, 'font-size', context.useElementContext);
    if (fontSize) {
        cssFont += asStyleString ? `font-size: ${fontSize};` : ` ${fontSize}`;
        effectiveAttributes.fontSize = fontSize;
    }
    if (context.fontFamily) {
        cssFont += asStyleString ? `font-family: ${context.fontFamily};` : ` ${context.fontFamily}`;
        effectiveAttributes.fontFamiliy = context.fontFamily;
    }
    else {
        const fontFamily = getEffectiveAttribute(context, text, 'font-family', context.useElementContext);
        if (fontFamily) {
            cssFont += asStyleString ? `font-family: ${fontFamily};` : ` ${fontFamily}`;
            effectiveAttributes.fontFamiliy = fontFamily;
        }
    }
    cssFont = cssFont.trim();
    return Object.assign(Object.assign({}, effectiveAttributes), { cssFont });
}
function copyTextStyleAttributes(context, srcElement, tgtElement) {
    const stroke = getEffectiveAttribute(context, srcElement, 'stroke');
    const strokeWidth = stroke ? getEffectiveAttribute(context, srcElement, 'stroke-width') : null;
    const fill = getEffectiveAttribute(context, srcElement, 'fill');
    const dominantBaseline = getEffectiveAttribute(context, srcElement, 'dominant-baseline');
    const textAnchor = getEffectiveAttribute(context, srcElement, 'text-anchor', context.useElementContext);
    if (stroke) {
        tgtElement.setAttribute('stroke', stroke);
    }
    if (strokeWidth) {
        tgtElement.setAttribute('stroke-width', strokeWidth);
    }
    if (fill) {
        tgtElement.setAttribute('fill', fill);
    }
    if (textAnchor) {
        tgtElement.setAttribute('text-anchor', textAnchor);
    }
    if (dominantBaseline) {
        tgtElement.setAttribute('dominant-baseline', dominantBaseline);
    }
}

function drawUse(context, use, svgTransform) {
    let href = use.href.baseVal;
    if (href.startsWith('#')) {
        href = href.substring(1);
    }
    const defElement = context.idElements[href];
    if (defElement) {
        let useWidth, useHeight;
        if (use.getAttribute('width') && use.getAttribute('height')) {
            // Use elements can overwrite the width which is important if it is a nested SVG
            useWidth = use.width.baseVal.value;
            useHeight = use.height.baseVal.value;
        }
        // We need to account for x and y attributes as well. Those change where the element is drawn.
        // We can simply change the transform to include that.
        const x = use.x.baseVal.value;
        const y = use.y.baseVal.value;
        let matrix = context.sourceSvg.createSVGMatrix().translate(x, y);
        matrix = svgTransform ? svgTransform.matrix.multiply(matrix) : matrix;
        // the defsElement itself might have a transform that needs to be incorporated
        const elementTransform = context.sourceSvg.createSVGTransformFromMatrix(matrix);
        // use elements must be processed in their context, particularly regarding
        // the styling of them
        if (!context.useElementContext) {
            context.useElementContext = { root: use, referenced: defElement, parentContext: null };
        }
        else {
            const newContext = {
                root: use,
                referenced: defElement,
                parentContext: Object.assign({}, context.useElementContext)
            };
            context.useElementContext = newContext;
        }
        // draw the referenced element
        context.processElement(context, defElement, getCombinedTransform(context, defElement, elementTransform), useWidth, useHeight);
        // restore default context
        if (context.useElementContext.parentContext) {
            context.useElementContext = context.useElementContext.parentContext;
        }
        else {
            context.useElementContext = null;
        }
    }
}

/**
 * Traverses the SVG in DFS and draws each element to the canvas.
 * @param root either an SVG- or g-element
 * @param width Use elements can overwrite width
 * @param height Use elements can overwrite height
 */
function processRoot(context, root, svgTransform, width, height) {
    var _a, _b;
    // traverse svg in DFS
    const stack = [];
    const currentViewBox = { x: 0, y: 0, w: width !== null && width !== void 0 ? width : 0, h: height !== null && height !== void 0 ? height : 0 };
    if (root instanceof SVGSVGElement ||
        root instanceof SVGSymbolElement ||
        root instanceof SVGMarkerElement) {
        let rootX = 0;
        let rootY = 0;
        if (root instanceof SVGSymbolElement) {
            rootX = parseFloat((_a = root.getAttribute('x')) !== null && _a !== void 0 ? _a : '') || 0;
            rootY = parseFloat((_b = root.getAttribute('y')) !== null && _b !== void 0 ? _b : '') || 0;
            width = width !== null && width !== void 0 ? width : (parseFloat(root.getAttribute('width')) || void 0);
            height = height !== null && height !== void 0 ? height : (parseFloat(root.getAttribute('height')) || void 0);
        }
        else if (root instanceof SVGMarkerElement) {
            // markers use refX / refY which is applied after user-space transformation
            const mw = root.getAttribute('markerWidth');
            const mh = root.getAttribute('markerHeight');
            width = mw !== null ? parseFloat(mw) : 3; // marker-size is 3 by SVG spec
            height = mh !== null ? parseFloat(mh) : 3;
        }
        else if (root !== context.sourceSvg) {
            // apply translation of nested elements
            rootX = root.x.baseVal.value;
            rootY = root.y.baseVal.value;
        }
        let rootTransform = context.sourceSvg.createSVGMatrix();
        if (root.getAttribute('viewBox')) {
            const { x: viewBoxX, y: viewBoxY, width: viewBoxWidth, height: viewBoxHeight } = root.viewBox.baseVal;
            currentViewBox.x = viewBoxX;
            currentViewBox.y = viewBoxY;
            currentViewBox.w = viewBoxWidth;
            currentViewBox.h = viewBoxHeight;
            if (typeof width !== 'undefined' && typeof height !== 'undefined') {
                // viewBox values might scale the SVGs content
                const sx = width / viewBoxWidth;
                const sy = height / viewBoxHeight;
                const centerviewportX = rootX + width * 0.5;
                const centerviewportY = rootY + height * 0.5;
                const centerViewBoxX = viewBoxX + viewBoxWidth * 0.5;
                const centerViewBoxY = viewBoxY + viewBoxHeight * 0.5;
                // only support scaling from the center, e.g. xMidYMid
                rootTransform = rootTransform.translate(centerviewportX, centerviewportY);
                if (root.getAttribute('preserveAspectRatio') === 'none') {
                    rootTransform = rootTransform.scaleNonUniform(sx, sy);
                }
                else {
                    rootTransform = rootTransform.scale(Math.min(sx, sy));
                }
                rootTransform = rootTransform.translate(-centerViewBoxX, -centerViewBoxY);
            }
        }
        else {
            rootTransform = rootTransform.translate(rootX, rootY);
        }
        if (root instanceof SVGMarkerElement) {
            // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/refX#symbol
            // ref coordinates are interpreted as being in the coordinate system of the element contents,
            // after application of the viewBox and preserveAspectRatio attributes.
            rootTransform = rootTransform.translate(-root.refX.baseVal.value, -root.refY.baseVal.value);
        }
        const combinedMatrix = svgTransform
            ? svgTransform.matrix.multiply(rootTransform)
            : rootTransform;
        svgTransform = context.sourceSvg.createSVGTransformFromMatrix(combinedMatrix);
        // don't put the SVG itself into the stack, so start with the children of it
        const children = getNodeChildren(root);
        for (let i = children.length - 1; i >= 0; i--) {
            const child = children[i];
            if (child instanceof SVGSymbolElement || child instanceof SVGMarkerElement) {
                // symbols and marker can only be instantiated by specific elements
                continue;
            }
            const childTransform = getCombinedTransform(context, child, svgTransform);
            stack.push({ element: child, transform: childTransform, viewBox: currentViewBox });
        }
    }
    else {
        stack.push({ element: root, transform: svgTransform, viewBox: currentViewBox });
    }
    while (stack.length > 0) {
        const { element, transform, viewBox } = stack.pop();
        // maybe draw the element
        try {
            context.viewBox = viewBox;
            drawElement(context, element, transform);
        }
        catch (e) {
            console.error(e);
        }
        if (element.tagName === 'defs' ||
            element.tagName === 'symbol' ||
            element.tagName === 'marker' ||
            element.tagName === 'svg' ||
            element.tagName === 'clipPath') {
            // Defs are prepocessed separately.
            // Symbols and marker can only be instantiated by specific elements.
            // Don't traverse the SVG element itself. This is done by drawElement -> processRoot.
            // ClipPaths are not drawn and processed separately.
            continue;
        }
        // process children
        const children = getNodeChildren(element);
        for (let i = children.length - 1; i >= 0; i--) {
            const childElement = children[i];
            const newTransform = getCombinedTransform(context, childElement, transform);
            stack.push({ element: childElement, transform: newTransform, viewBox });
        }
    }
}
function drawRoot(context, element, svgTransform) {
    let width = parseFloat(element.getAttribute('width'));
    let height = parseFloat(element.getAttribute('height'));
    if (isNaN(width) || isNaN(height)) {
        // use only if both are set
        width = height = undefined;
    }
    processRoot(context, element, svgTransform, width, height);
}
/**
 * The main switch to delegate drawing of `SVGElement`s
 * to different subroutines.
 */
function drawElement(context, element, svgTransform) {
    if (isHidden(element)) {
        // just skip hidden elements
        return;
    }
    // possibly apply a clip on the canvas before drawing on it
    const clipPath = element.getAttribute('clip-path');
    if (clipPath) {
        applyClipPath(context, element, clipPath, svgTransform);
    }
    switch (element.tagName) {
        case 'svg':
        case 'symbol':
            drawRoot(context, element, svgTransform);
            break;
        case 'rect':
            drawRect(context, element, svgTransform);
            break;
        case 'path':
            drawPath(context, element, svgTransform);
            break;
        case 'use':
            drawUse(context, element, svgTransform);
            break;
        case 'line':
            drawLine(context, element, svgTransform);
            break;
        case 'circle':
            drawCircle(context, element, svgTransform);
            break;
        case 'ellipse':
            drawEllipse(context, element, svgTransform);
            break;
        case 'polyline':
            drawPolyline(context, element, svgTransform);
            break;
        case 'polygon':
            drawPolygon(context, element, svgTransform);
            break;
        case 'text':
            drawText(context, element, svgTransform);
            break;
        case 'image':
            drawImage(context, element, svgTransform);
            break;
        case 'foreignObject':
            drawForeignObject(context, element, svgTransform);
            break;
    }
}

function createPencilFilter() {
    const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
    filter.setAttribute('id', 'pencilTextureFilter');
    filter.setAttribute('x', '0%');
    filter.setAttribute('y', '0%');
    filter.setAttribute('width', '100%');
    filter.setAttribute('height', '100%');
    filter.setAttribute('filterUnits', 'objectBoundingBox');
    const feTurbulence = document.createElementNS('http://www.w3.org/2000/svg', 'feTurbulence');
    feTurbulence.setAttribute('type', 'fractalNoise');
    feTurbulence.setAttribute('baseFrequency', '2');
    feTurbulence.setAttribute('numOctaves', '5');
    feTurbulence.setAttribute('stitchTiles', 'stitch');
    feTurbulence.setAttribute('result', 'f1');
    filter.appendChild(feTurbulence);
    const feColorMatrix = document.createElementNS('http://www.w3.org/2000/svg', 'feColorMatrix');
    feColorMatrix.setAttribute('type', 'matrix');
    feColorMatrix.setAttribute('values', '0 0 0 0 0, 0 0 0 0 0, 0 0 0 0 0, 0 0 0 -1.5 1.5');
    feColorMatrix.setAttribute('result', 'f2');
    filter.appendChild(feColorMatrix);
    const feComposite = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
    feComposite.setAttribute('operator', 'in');
    feComposite.setAttribute('in', 'SourceGraphic');
    feComposite.setAttribute('in2', 'f2');
    feComposite.setAttribute('result', 'f3');
    filter.appendChild(feComposite);
    return filter;
}

/**
 * A simple random number generator that allows for seeding.
 */
class RandomNumberGenerator {
    constructor(seed) {
        // since we already depend on Rough.js, we may just use its seedable RNG implementation
        this.rng = seed ? new Random(seed) : null;
    }
    /**
     * Returns a random number in the given range.
     */
    next(range) {
        var _a, _b;
        const rnd = (_b = (_a = this.rng) === null || _a === void 0 ? void 0 : _a.next()) !== null && _b !== void 0 ? _b : Math.random();
        if (range) {
            const min = range[0];
            const max = range[1];
            return rnd * (max - min) + min;
        }
        return rnd;
    }
}

/**
 * Svg2Roughjs parses an SVG and converts it to a hand-drawn sketch.
 */
class Svg2Roughjs {
    /**
     * Set the SVG that should be sketched.
     */
    set svg(svg) {
        if (this.$svg !== svg) {
            this.$svg = svg;
            this.sourceSvgChanged();
        }
    }
    /**
     * Returns the SVG that should be sketched.
     */
    get svg() {
        return this.$svg;
    }
    /**
     * Sets the output format of the sketch.
     *
     * Applies only to instances that have been created with a
     * container as output element instead of an actual SVG or canvas
     * element.
     *
     * Throws when the given mode does not match the output element
     * with which this instance was created.
     */
    set outputType(type) {
        if (this.$outputType === type) {
            return;
        }
        const incompatible = (type === OutputType.CANVAS && this.outputElement instanceof SVGSVGElement) ||
            (type === OutputType.SVG && this.outputElement instanceof HTMLCanvasElement);
        if (incompatible) {
            throw new Error(`Output format ${type} incompatible with given output element ${this.outputElement.tagName}`);
        }
        this.$outputType = type;
    }
    /**
     * Returns the currently configured output type.
     */
    get outputType() {
        return this.$outputType;
    }
    /**
     * Sets the config object that is passed to Rough.js and considered
     * during rendering of the `SVGElement`s.
     *
     * Sets `fixedDecimalPlaceDigits` to `3` if not specified otherwise.
     */
    set roughConfig(config) {
        if (typeof config.fixedDecimalPlaceDigits === 'undefined') {
            config.fixedDecimalPlaceDigits = 3;
        }
        this.$roughConfig = config;
    }
    /**
     * Returns the currently configured rendering configuration.
     */
    get roughConfig() {
        return this.$roughConfig;
    }
    /**
     * Creates a new instance of Svg2roughjs.
     * @param target Either a container `HTMLDivElement` (or a selector for the container) to which a sketch should be added
     * or an `HTMLCanvasElement` or `SVGSVGElement` that should be used as output target.
     * @param outputType Whether the output should be an SVG or drawn to an HTML canvas.
     * Defaults to SVG or CANVAS depending if the given target is of type `HTMLCanvasElement` or `SVGSVGElement`,
     * otherwise it defaults to SVG.
     * @param roughConfig Config object that is passed to Rough.js and considered during
     * rendering of the `SVGElement`s.
     */
    constructor(target, outputType = OutputType.SVG, roughConfig = {}) {
        /**
         * Optional solid background color with which the canvas should be initialized.
         * It is drawn on a transparent canvas by default.
         */
        this.backgroundColor = null;
        /**
         * Set a font-family for the rendering of text elements.
         * If set to `null`, then the font-family of the SVGTextElement is used.
         * By default, 'Comic Sans MS, cursive' is used.
         */
        this.fontFamily = 'Comic Sans MS, cursive';
        /**
         * Whether to randomize Rough.js' fillWeight, hachureAngle and hachureGap.
         * Also randomizes the disableMultiStroke option of Rough.js.
         * The randomness may be seeded with the `seed` property.
         * By default `true`.
         */
        this.randomize = true;
        /**
         * Optional seed for the randomness when creating the sketch.
         * Providing a value implicitly seeds Rough.js which may be overwritten
         * by provding a different seed with the optional `roughConfig` property.
         * By default `null`.
         */
        this.seed = null;
        /**
         * Whether pattern elements should be sketched or just copied to the output.
         * For smaller pattern base sizes, it's often beneficial to just copy it over
         * as the sketch will be too smalle to actually look sketched at all.
         */
        this.sketchPatterns = true;
        /**
         * Whether to apply a pencil filter.
         */
        this.pencilFilter = false;
        this.width = 0;
        this.height = 0;
        this.$roughConfig = {};
        this.idElements = {};
        this.lastResult = null;
        if (!target) {
            throw new Error('No target provided');
        }
        const targetElement = typeof target === 'string' ? document.querySelector(target) : target;
        if (!targetElement) {
            throw new Error('Could not find target in document');
        }
        this.roughConfig = roughConfig;
        this.outputElement = targetElement;
        if (targetElement instanceof HTMLCanvasElement) {
            this.$outputType = OutputType.CANVAS;
        }
        else if (targetElement instanceof SVGSVGElement) {
            this.$outputType = OutputType.SVG;
        }
        else {
            this.$outputType = outputType;
        }
    }
    /**
     * Triggers an entire redraw of the SVG which
     * processes the input element anew.
     * @param sourceSvgChanged When `true`, the given {@link svg} is re-evaluated as if it was set anew.
     *  This allows the Svg2Rough.js instance to be used mutliple times with the same source SVG container but different contents.
     * @returns A promise that resolves with the sketched output element or null if no {@link svg} is set.
     */
    sketch(sourceSvgChanged = false) {
        var _a, _b;
        if (!this.svg) {
            return Promise.resolve(null);
        }
        if (sourceSvgChanged) {
            this.sourceSvgChanged();
        }
        const sketchContainer = this.prepareRenderContainer();
        const renderContext = this.createRenderContext(sketchContainer);
        // prepare filter effects
        if (this.pencilFilter) {
            const defs = getDefsElement(renderContext);
            defs.appendChild(createPencilFilter());
        }
        // sketchify the SVG
        renderContext.processElement(renderContext, this.svg, null, this.width, this.height);
        if (this.outputElement instanceof SVGSVGElement) {
            // sketch already in the outputElement
            return Promise.resolve(this.outputElement);
        }
        else if (this.outputElement instanceof HTMLCanvasElement) {
            return this.drawToCanvas(renderContext, this.outputElement);
        }
        // remove the previous attached result
        (_b = (_a = this.lastResult) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(this.lastResult);
        // assume that the given output element is a container, thus append the sketch to it
        if (this.outputType === OutputType.SVG) {
            const svgSketch = renderContext.svgSketch;
            this.outputElement.appendChild(svgSketch);
            this.lastResult = svgSketch;
            return Promise.resolve(svgSketch);
        }
        else {
            // canvas output type
            const canvas = document.createElement('canvas');
            this.outputElement.appendChild(canvas);
            this.lastResult = canvas;
            return this.drawToCanvas(renderContext, canvas);
        }
    }
    /**
     * Creates a new context which contains the current state of the
     * Svg2Roughs instance for rendering.
     */
    createRenderContext(sketchContainer) {
        if (!this.svg) {
            throw new Error('No source SVG set yet.');
        }
        let roughConfig = this.roughConfig;
        if (this.seed !== null) {
            roughConfig = Object.assign({ seed: this.seed }, roughConfig);
        }
        return {
            rc: rough.svg(sketchContainer, { options: roughConfig }),
            roughConfig: this.roughConfig,
            fontFamily: this.fontFamily,
            pencilFilter: this.pencilFilter,
            randomize: this.randomize,
            rng: new RandomNumberGenerator(this.seed),
            sketchPatterns: this.sketchPatterns,
            idElements: this.idElements,
            sourceSvg: this.svg,
            svgSketch: sketchContainer,
            svgSketchIsInDOM: document.body.contains(sketchContainer),
            styleSheets: Array.from(this.svg.querySelectorAll('style'))
                .map(s => s.sheet)
                .filter(s => s !== null),
            processElement: processRoot
        };
    }
    /**
     * Helper method to draw the sketched SVG to a HTMLCanvasElement.
     */
    drawToCanvas(renderContext, canvas) {
        canvas.width = this.width;
        canvas.height = this.height;
        const canvasCtx = canvas.getContext('2d');
        canvasCtx.clearRect(0, 0, this.width, this.height);
        return new Promise(resolve => {
            const svgString = new XMLSerializer().serializeToString(renderContext.svgSketch);
            const img = new Image();
            img.onload = function () {
                canvasCtx.drawImage(this, 0, 0);
                resolve(canvas);
            };
            img.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgString)}`;
        });
    }
    /**
     * Prepares the given SVG element depending on the set properties.
     */
    prepareRenderContainer() {
        let svgElement;
        if (this.outputElement instanceof SVGSVGElement) {
            // just use the user given outputElement directly as sketch-container
            svgElement = this.outputElement;
        }
        else {
            // we need a separate svgElement as output element
            svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        }
        // make sure it has all the proper namespaces
        svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        svgElement.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');
        // clear SVG element
        while (svgElement.firstChild) {
            svgElement.removeChild(svgElement.firstChild);
        }
        // set size
        svgElement.setAttribute('width', this.width.toString());
        svgElement.setAttribute('height', this.height.toString());
        // apply backgroundColor
        let backgroundElement;
        if (this.backgroundColor) {
            backgroundElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            backgroundElement.width.baseVal.value = this.width;
            backgroundElement.height.baseVal.value = this.height;
            backgroundElement.setAttribute('fill', this.backgroundColor);
            svgElement.appendChild(backgroundElement);
        }
        // use round linecap to emphasize a ballpoint pen like drawing
        svgElement.setAttribute('stroke-linecap', 'round');
        return svgElement;
    }
    /**
     * Initializes the size based on the currently set SVG and collects elements
     * with an ID property that may be referenced in the SVG.
     */
    sourceSvgChanged() {
        const svg = this.$svg;
        if (svg) {
            const precision = this.roughConfig.fixedDecimalPlaceDigits;
            this.width = parseFloat(this.coerceSize(svg, 'width', 300).toFixed(precision));
            this.height = parseFloat(this.coerceSize(svg, 'height', 150).toFixed(precision));
            // pre-process defs for subsequent references
            this.collectElementsWithID();
        }
    }
    /**
     * Stores elements with IDs for later use.
     */
    collectElementsWithID() {
        this.idElements = {};
        const elementsWithID = Array.prototype.slice.apply(this.svg.querySelectorAll('*[id]'));
        for (const elt of elementsWithID) {
            const id = elt.getAttribute('id');
            if (id) {
                this.idElements[id] = elt;
            }
        }
    }
    /**
     * Helper to handle percentage values for width / height of the input SVG.
     */
    coerceSize(svg, property, fallback) {
        let size = fallback;
        const hasViewbox = svg.hasAttribute('viewBox');
        if (svg.hasAttribute(property)) {
            // percentage sizes for the root SVG are unclear, thus use viewBox if available
            if (svg[property].baseVal.unitType === SVGLength.SVG_LENGTHTYPE_PERCENTAGE && hasViewbox) {
                size = svg.viewBox.baseVal[property];
            }
            else {
                size = svg[property].baseVal.value;
            }
        }
        else if (hasViewbox) {
            size = svg.viewBox.baseVal[property];
        }
        return size;
    }
}

export { OutputType, Svg2Roughjs };
//# sourceMappingURL=svg2roughjs.es.js.map
